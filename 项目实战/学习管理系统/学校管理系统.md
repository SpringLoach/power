## 个人理解

- 很多地方可以用函数声明却用了函数表达式，不美观也麻烦
- 很多逻辑层面的过度封装，导致框架追溯底层变得麻烦
- 由于很多处理逻辑（如期约的then）放在了其他文件，造成大量使用context传递组件实例
- 很多时候传递具体的组件实例，只是为了使用它原型上的其他属性（如$router），很绕感觉很没必要
- 大量的for循环、不严格的空格排版
- 表格头、表单的验证规则、表单绑定数据等逻辑都被分离出组件本身
- 有很多地方依靠箭头函数和期约可以把逻辑写得清晰简洁很多  
- 由于使用了HBuildx，无法做到单文档分栏，导致每个组件的样式、许多逻辑都被分到别的文档，难以追踪
- css样式，类名与括号间没加空格、参数间不加空格、对象属性间不加空格、多步骤不加括号
- 合并数组使用循环加push，代码量多，写法不太好。合并数组直接就有concat方法，用展开操作符也行



## 有待补充

- break 用于跳出循环，而不是跳出条件？有助于满足条件后，减少循环次数。这个用数组的 some 方法就能办到。



## main.ts

```javascript
import Vue from 'vue';
import App from './App.vue';

import router from './router';
import store from './store';
import axios from 'axios';
import qs from 'qs';

/* 完整引入 Ant 组件及样式、并额外将消息组件和图标组件导出 */
import Antd, {Icon, message}  from 'ant-design-vue';
import 'ant-design-vue/dist/antd.css';

/* 导入组件，用于全局注册 */
import pageHead from './components/top.vue'; 
import pageBottom from './components/bottom.vue';

/* 导入全局样式和图标样式 */
import './assets/css/global.scss';
import './assets/fonts/iconfont.css';

/* 导入一些辅助方法，将添加到原型上，每个实例都可以访问 */
import loading from './js/loading';
import baseConfig from './js/config.js';
import app from './js/app.js';
import roleHelper from './js/roleHelper.js';
import basicRequest from './js/basicRequest.js';
import pageHelper from './js/pageHelper.js';

/* 关闭生产模式下给出的提示 */
Vue.config.productionTip = false;

Vue.use(Antd); 

Vue.prototype.$store = store;
Vue.prototype.$http = axios;
Vue.prototype.$qs = qs;
Vue.prototype.$message = message;

Vue.prototype.$loading = loading;
Vue.prototype.$baseConfig = baseConfig;
Vue.prototype.$app = app;
Vue.prototype.$roleHelper = roleHelper;
Vue.prototype.$basicRequest = basicRequest;
Vue.prototype.$pageHelper = pageHelper;

/* 自定义 font 图标 */
const IconFont = Icon.createFromIconfontCN({
	/* 导入本地文件要用require */
	scriptUrl: require("./assets/fonts/iconfont.js")
    
    /* 实际上也可以使用网络地址 */
    // scriptUrl: '//at.alicdn.com/t/font_2745733_00dww5mfg9ki7.js'
});

Vue.component('page-top',pageHead);
Vue.component('page-bottom',pageBottom);
Vue.component('c-font-icon',IconFont);

new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')
```

项目 | 说明
:- | :-
qs | 可以在url的查询部分与js对象之间[相互转换](https://blog.csdn.net/suwu150/article/details/78333452)
[Icon.createFromIconfontCN](https://www.antdv.com/components/icon-cn/#自定义-font-图标) | 全局注册后，组件渲染前会自动引入项目中的图标集
iconfont.js | [图表库](https://www.iconfont.cn/) - 具体项目 - Symbol - 弹出网页展示的代码 - 拷贝

## App.vue  

```vue
<template>
	<a-config-provider :locale="zhCN">
		<div id="app">
			<a-spin :spinning="loading" :tip="loadingTip">
				<router-view />
			</a-spin>
		</div>
	</a-config-provider>
</template>
<script>
	import {mapState,mapMutations} from 'vuex'
	import zhCN from 'ant-design-vue/lib/locale-provider/zh_CN';
	import moment from 'moment';
	import 'moment/locale/zh-cn';

	moment.locale('zh-cn');

	export default {
		data() {
			return {
				zhCN,
			};
		},
		computed: {
		    /* 将状态管理中的状态，以同名方式作为该组件的计算属性 */
			...mapState(["loading","loadingTip"]),
			/* 等价于
			loading(){
				return this.$store.state.loading;
			},
			loadingTip(){
				return this.$store.state.loadingTip;
			}*/
		}
	};
</script>
```

组件 | 属性 | 说明
:- | :- | :-
a-config-provider | locale | 语言包配置，可到 ant-design-vue/lib/locale-provider/ 目录下寻找
a-spin | spinning | 是否为加载中状态
a-spin | tip | 作为**包裹元素**时的自定义描述文案

### moment
> 日期处理类库，用于解析、操作、显示日期。  

#### 设定moment区域为中国  

```javascript
import moment from 'moment';
import 'moment/locale/zh-cn';

moment.locale('zh-cn');
```

## store
> index.ts

```javascript
export default new Vuex.Store({
  state: {
	  loading: false,
	  loadingTip:""
  },
  mutations: {
	showLoading(state:any, opt?:any){
		state.loadingTip = (opt===undefined)||!opt.tips?"加载中，请稍等……":opt.tips;
		state.loading = true;   
	},
	hideLoading (state) {
		state.loading = false;
	}
  }
})
```

> 若没有传入配置，使用默认提示。即使传入了配置，也要先检查该配置对象是否合规。  



## loading.ts

> 个人认为很多余的封装，强制使开发环境脱离VueX的正常使用，为此还要多此一举传入组件实例。  

```typescript
const showLoading = function(context:any,opt?:any){
	context.$store.commit("showLoading",opt);
};
const hideLoading = function(context:any){
	context.$store.commit("hideLoading");
};

export default {
	showLoading,
	hideLoading
};
```

## validate.js.js

```javascript
export const regular = {
	// 验证自然数
	naturalNumber: /^(([0-9]*[1-9][0-9]*)|(0+))$/,
	naturalNumberMsg: '请输入自然数',
	// 微信号
	wechat: /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/,
	wechatMsg: '请输入正确的微信号码',
	// 英文
	english: /^.[A-Za-z]+$/,
	englishMsg: '请输入英文字符',
	// 手机
	phone: /^1[3|4|5|7|8][0-9]{9}$/,
	phoneMsg: '请输入正确的手机号',
	// 座机
	telephone: /^\d{3}-\d{7,8}|\d{4}-\d{7,8}$/,
	telephoneMsg: '请输入正确的座机号',
	// 银行卡号码
	bankCard: /^[1-9]\d{9,19}$/,
	bankCardMsg: '请输入正确的银行卡号码',
	// 证件号码
	IDNumber: /^[a-z0-9A-Z]{0,50}$/,
	IDNumberMsg: '请输入正确的证件号码',
	// 身份证号码,包括15位和18位的
	IDCard: /(^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$)|(^[1-9]\d{7}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}$)/,
	IDCardMsg: '请输入正确的身份证号码',
	// QQ号码
	qq: /^[1-9]\d{4,11}$/,
	qqMsg: '请输入正确的QQ号码',
	// 网址, 仅支持http和https开头的
	url: /^(http|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-.,@?^=%&:/~+#]*[\w\-@?^=%&/~+#])?$/,
	urlMsg: '请输入以http和https开头的网址',
	// 0到20位的英文字符和数字
	enNum0to20: /^[a-z0-9A-Z]{0,20}$/,
	enNum0to20Msg: '请输入20位以内的英文字符和数字',
	// 2到100位的中英文字符和空格
	cnEnSpace2to100: /^[a-zA-Z\u4E00-\u9FA5\s*]{2,100}$/,
	cnEnSpace2to100Msg: '请输入2到100位的中英文字符和空格',
	// 数字和换行符
	numLinefeed: /^[0-9\n*]+$/,
	numLinefeedMsg: '请输入数字和换行符',
	// 255位以内的字符
	char0to255: /^.{0,255}$/,
	char0to255Msg: '请输入255位以内的字符',
	// 特殊字符
	specialChar: /^[^`~!@#$^&*()=|{}':;',/\\[\].<>?]*$/,
	specialCharMsg: '请删除特殊字符',
	// 保留两位小数
	twoDecimal: /^(([0-9][0-9]*)|(([0]\.\d{1,2}|[0-9][0-9]*\.\d{1,2})))$/,
	twoDecimalMsg: '小数点保留最多两位'
}
/**
 * @description 排序值验证，排序值不可以大于255
 */
export const validateOrder = function(rule, value, callback) {
	if (parseInt(value) > 255) {
		return callback(new Error('排序值不可以大于255'))
	} else {
		callback()
	}
}
```

## roleHelper.js

> 拥有多个身份，每个身份有不同的权限和信息，根据相关信息可以判断其在是否具有某些入口权限。  

```javascript
/* 默认登录为学生端 */
const defaultAlias = "student";
const ROLE_CONFIG={
    // 拥有不同权限的各种身份
	system:{
		roleId:1331533939218,
		roleName:"系统管理员",
		use:11,
		alias:"manager",
		entranceName:"DMAI管理平台",
		account:"平台管理员",
		isShow:true
	},
	...,
    // 根据角色Id获取身份配置
	getByRoleId(roleId){
		for(let p in this){
			if(typeof this[p]=="function"){
				continue;
			}
			if(this[p].roleId == roleId){
				return this[p];
			}
		}	
		return undefined;
	},
	getByAlias(alias){...},
	
	/**
	 * 判断是否对用户开发该入口
	 * 注：如果入口为public则表示公用页面
	 * @param {Object} user 用户对象
	 * @param {Object} entrance 入口
	 */
        
    // 有些入口，多种身份都具有权限
    // 剩余的只有对应相应身份，才具备权限
	allowEntrance(user,entrance){
		let uses = user.role.uses;
		uses = uses.split(",");
		if(entrance=="public"){
			return true;
		}
		if(entrance=="race"){
			for(let i=0;i<uses.length;i++){          	  
				if(uses[i]==ROLE_CONFIG.teacher.use||uses[i]==ROLE_CONFIG.student.use||uses[i]==ROLE_CONFIG.race.use){
					return true;
				}
			}	
		}
		for(let p in this){
			let _item = this[p];
			if(typeof this[p]=="function"){
				continue;
			}
			for(let i=0;i<uses.length;i++){
				if((_item.use+"") === uses[i] && _item.alias == entrance){
					return true;
				}
			}
		}
		return false;
	}
};
/* 是否展示某些内容 */
const isShowTeachingMaterial=function(user,entrance){
	if(!user||!user.id){
		return false;
	}
	let roleId = user.role.id;
    // 下面这行没有用上
	let config = ROLE_CONFIG.getByRoleId(roleId);
	if(roleId==ROLE_CONFIG.student.roleId){
		return true;
	}else if(roleId==ROLE_CONFIG.teacher.roleId){
		return true;
	}else if(roleId==ROLE_CONFIG.auditor.roleId){
		return true;
	}else if(roleId==ROLE_CONFIG.creator.roleId){
		return true;
	}
	return false;
};
/* 直接调用对象中的方法并导出 */
const getByRoleId = function(roleId){
	return ROLE_CONFIG.getByRoleId(roleId);
};

export default {
	ROLE_CONFIG,
	defaultAlias,
	isShowTeachingMaterial,
	
	getByRoleId
};
```

## config.js

```javascript
//注意：正式发布前将此值设为false
const isDebug = false;

const defaultSettings = "aicp";

//DMAI-管理后台
const baseUrl_dmai_web = "/aicp-dmai-web"
//学校管理 
const baseUrl_school_web = "/aicp-school-web"
//教研系统
const baseUrl_creation_web = "/aicp-creation-web"
//教学
const baseUrl_teaching = "/aicp-teaching"


//别名，解决多程序情况下本地存储、更新冲突的问题
const appAlias = 'aicp_teaching_materials';

const stateKeyName = appAlias + "_$state_" + appAlias;

const tokenKeyName = appAlias + "_$tokenKeyName_" + appAlias;


//对应后台角色管理中:允许登录应用范围,21:代表会员移动
const use = 16;

export default{
  isDebug,
  defaultSettings,

  appAlias,
  stateKeyName,
  tokenKeyName,
  use
}
```

## app.js

> 本地缓存的设置、查看、删除方法被封装起来了，其中不仅有已知的状态、token、入口信息，未知缓存信息的设置方法也进行了封装。



isToLogout 看不懂用途

roleHelper.ROLE_CONFIG.defaultAlias 不存在该属性

工程名的含义是什么，子域名？表述不清晰

[new url()](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/URL)

[URL.origin](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/origin)



```javascript
import appConfig from './config.js';
import roleHelper from './roleHelper.js';

/* 设置当前状态 */
const setState = function(state) {
	state = state || {};
	state.id = state._id;    // 兼容写法，估计是后端没处理好，两种属性都有
	window.localStorage.setItem(appConfig.stateKeyName, JSON.stringify(state));
};

/* 判断是否登录 */
const whetherLand = function() {
	var state = getState();
	if (state.id == undefined && state._id == undefined) {
		return false;
	}
	return true;
};


/**
 * 本地退出登录，不做任何网络请求
 * @param {Object} isToLogin 是否跳转到登录页面
 */
const localLogout = function(context,isToLogout){
    // 清理缓存中相应的键值对  
	clearToken();
	clearState();
	isToLogout = isToLogout===undefined?true:isToLogout;
	if(isToLogout){
		toLogin(context);
	}
};

/* 跳转到登录页面，登录后使用 */
const toLogin = function(context){
	let path = getLoginPath();
	context.$router.push(path);
};

/* 目前来看，梳理出来有点多余 */
const getLoginPath = function(){
	return "/login";
};

/* 得到URL上的根目录（除去工程名后的第一层） */
const getUrlRootName = function(path){
	if(!path){
		return roleHelper.ROLE_CONFIG.defaultAlias;
	}
	let paths = path.split("/"); // 转化为数组 
	if(paths.length<2){
		return roleHelper.ROLE_CONFIG.defaultAlias;
	}
	return paths[1];
};

/* 协议://域名:端口/工程名 */
const getUrlRoot = function(context){
	let path = context.$route.path;
	let rootName = getUrlRootName(path);
	
	let url = document.location.href;
	var myURL = new URL(url);
	let origin = myURL.origin; // 协议://域名:端口
	return origin+"/"+rootName;
};
/* 协议://域名:端口 */
const getUrlDomainName = function(context){
	let url = document.location.href;
	var myURL = new URL(url);
	return myURL.origin;
};

export default {
	setItem,
	getItem,
	clearItem,
	
	getUrlRootName,
	getUrlRoot,
	getUrlDomainName
};
```



### localStorage储存对象

- 由于`localStorage`会将值自动转换为字符串形式，无法直接存储对象

- JSON.stringify()  将JavaScript值转换为 JSON 字符串
- JSON.parse() 将数据转换为JavaScript对象

```javascript
/* 设置值 */
window.localStorage.setItem(key, JSON.stringify(value));

/* 获取值 */
let value = window.localStorage.getItem(key);
if (value == "" || !value) {
    value = "{}";
}
value = JSON.parse(value);
```

## basic.form.helper.js

> 深拷贝方法和数组的 findIndex 方法。
>
> 用于拷贝表单数据、判断文件类型是否在要求内。  



## listRequest.js

> 设置的默认值，会与传入参数进行合并，重复部分会被传入参数覆盖。



| 要点        | 说明                                                    |
| :---------- | :------------------------------------------------------ |
| opt.success | 提供了默认的success方法，外部（通常）未传入时，发挥作用 |

### 默认success

| 顺序 | 说明                                                         |
| :--: | :----------------------------------------------------------- |
|  ①   | 拿到数据后，先执行prepareRender，这步可以给每个条目新增、修改属性等 |
|  ②   | 拿到外部传入的pager，给它新增属性rows用于保存**数据**（在这步可以给每项数据添加额外属性） |
|  ③   | 将总条数total赋值到pager的属性上                             |
|  ④   | 将有无更多页数status赋值到pager的属性上                      |
|  ⑤   | 如果请求到的数据为空，执行empty方法                          |
|  ⑥   | 执行afterRender                                              |

#### prepareRender

- 其实已经请求到数据了，可以对数据做一些处理后，**返回数据**，其后的步骤负责将数据保存到页面。

#### afterRender

- 在将数据保存到页面后进行的处理，拿到的参数就是经过 prepareRender 和 其他处理后的数据。

#### 迷惑

1. 在 com-select-expand-lab.vue 中的 `getSubjectsList` 方法，调用了 `courseApi.getSubjectsList`, 传入的 pager 属性为一个数组，为什么在listRequest.js中的85-93行，像对象一样取pager的属性，前面写好的success方法中，也是给pager添加了不同的属性，这里？
2. 在 com-select-expand-lab.vue 中的 `getSubjectsList` 方法，调用了 `courseApi.getSubjectsList`，它的afterRender里为什么还要return data呢
3. 在 com-select-expand-lab.vue 中的 `getSubjectsList` 方法，调用了 `courseApi.getSubjectsList`，它的afterRender里为什么还要把数据提出来保存到页面，内部不是已经将处理后的请求数据保存到相应的pager上了吗



### 示例

#### getList

> 标准的getList请求，由于组件实例中保存了已选实验的ID，在prepareRender中，可以遍历 （当前页的）请求数据（的ID属性）与已选实验的ID进行匹配，动态改变数据项的属性值 `selected` 表示已选/未选。

| 索引 | 标准提供                         |
| :--: | :------------------------------- |
|  ①   | 上下文                           |
|  ②   | 查询参数                         |
|  ③   | me.pager.default，对于确切的表格 |
|  ④   | 子路径                           |

```javascript
import listRequest from '../../js/listRequest.js';
import {labApi} from '@/api';

pager:any = {
	default: {
		pagesize: (listRequest.pagesize as number),
		pagenum: 1,
		total: 10,
		rows: []
	}
};

getList(){
	let me = this;
	let urlQueryParmas = {
		courseIds:this.courseIds,
		environment:this.query.experiClassify,
		query:this.query.likeValue,
		participateWays:this.query.model
	};
	let url = "/v1/resource/expandexperimentresource/list";
	labApi.getList({
		context: me,
		pager: me.pager.default,
		urlQueryParmas: urlQueryParmas,
		url: url,
		prepareRender(data: any) { ... }
	})
};
```

#### getList_labApi

| 索引 | 标准提供                                                     | 必填 |
| :--: | :----------------------------------------------------------- | :--: |
|  ①   | 路径                                                         |      |
|  ②   | 上下文                                                       |      |
|  ③   | urlQueryParmas，内部进行了判断，其值为undefined时不会进行拼接 |  否  |
|  ④   | pager                                                        |      |
|  ⑤   | listDataKeyName，将转化为请求数据保存到本地时的**属性名**    |  否  |
|  ⑥   | data                                                         |  否  |
|  ⑦   | prepareRender                                                |  否  |

```javascript
getList(opt:any,pageData?:any){
	var servicesPath = baseURL + opt.url;
	let context = opt.context;
	let pager = opt.pager;
	if(opt.prepareRender == undefined){
		opt.prepareRender = function(data:any) {
			return data;
		};
	} 
	listRequest.request({
		url: servicesPath,
		context: context,
		pager: pager,
		listDataKeyName: "list",
		data: {},
		urlQueryParmas: opt.urlQueryParmas,
		prepareRender: opt.prepareRender
	});
},
```



## basicRequest.js

### 参数拼接

> 内部进行了两种处理。

#### 传入data

> 如果是GET请求会被赋值到 `requestOpt.params`，否则赋值到 `requestOpt.data`。
>
> 因为axios的GET请求不能使用 data，比较好理解。

#### 传入urlQueryParmas

> 会被直接拼接到路径后，如

```
let requestUrl = 'www.123.com'
let urlParams = {
  school: 'zhongyuan',
  sex: 'male'
}
requestUrl = this.appendUrlParameter(requestUrl, urlParams);
// 'www.123.com?school=zhongyuan&sex=male'
```

#### 总结

> 如果使用GET请求，只能传入params属性（会被拼接到路径），故使用data和urlQueryParmas都可以。

| POST请求  |     方式一     |  方式二  |
| :-------: | :------------: | :------: |
| 传参方式  |    拼接路径    | 传入实体 |
| 对应axios |     params     |   data   |
| 对应框架  | urlQueryParmas |   data   |

## PageHelper.js

### 其他文件_使用案例

> 本质上，先通过 loadCodes 方法获取到多个条目的分类数据，待获取到请求数据后，执行 initPageDataItem 方法，根据键从请求数据中找到需要的部分，并（在处理后）将它保存到首参中。

| 索引 | 标准提供                                                |
| :--: | :------------------------------------------------------ |
|  ①   | 上下文                                                  |
|  ②   | multipleCodeStr，需要查询的多项类目                     |
|  ③   | success，并在其中调用 initPageDataItem 以筛选需要的数据 |



```javascript
this.$pageHelper.loadCodes({
	context: this,
	multipleCodeStr: "test_platform, entry_type, learning_section",
	// 参数 codesJson 在内部调用时传递，为根据多个查询键请求到的多类别数据
	success(codesJson:any) {
		me.$pageHelper.initPageDataItem(me.pageData.periodList, codesJson,"learning_section"); 
		me.$pageHelper.initPageDataItem(me.pageData.experiClassifyList, codesJson, "test_platform");
		me.$pageHelper.initPageDataItem(me.pageData.modeList, codesJson, "entry_type");
		me.getSubjectsList(function(){
			me.getList();
		});
	}
});
```

### 核心部分

```javascript
const loadCodes = function(parameters) {
	let multipleCodeStr = parameters.multipleCodeStr; 
	let success = parameters.success;
	let error = parameters.error;
	let context = parameters.context;
	
	let url = loadCodesItemUrl;
	basicRequest.request({
		context,
		url: url,
		ajaxOpt:{ 
			type: 'GET', 
		},
		data: {
			codes: multipleCodeStr
		},
		success(data, parameters) {
			let codesJson = data.data;
		
			if (typeof success == "function") {
			    // 这里调用的 success 是外部传入的success
				success(codesJson);
			}
		},
		error(error, message, parameters) {
			console.error("loadCodes-error",message);
			if (typeof error == "function") {
				error();
			}else{
				context.$message.error('程序执行异常，请与管理员联络!\n' + message);
			}
		}
	});
};

/** loadCodes会返回多个编码明细，将指定的codeKey加入到对应pageData属性中 
*   需配合loadCodes，获取到数据后使用 
*   可以排除不需要的值、添加额外属性 
*/
const initPageDataItem = function(target, codesJson, codeKey, parseValueToInt, option) {
	if (!codesJson[codeKey]) {
		return;
	}

	let opt = { //Axios默认配置
		excludeValues:[]//排除的数据项
	};
	opt = {
		...opt,
		...option
	};

	let excludeValues = opt.excludeValues;
	let includeOtherPropertys = opt.includeOtherPropertys||[];//包含的其它属性

	let codeItems = codesJson[codeKey];
	for (let i = 0; i < codeItems.length; i++) {
		let value = codeItems[i].value;
		if (parseValueToInt) {
			value = value - 0;
		}
		if (_isExistExcludeValue(value, excludeValues)) {
			continue;
		}
		let item = {
			id:codeItems[i].id,
			label: codeItems[i].name,
			name: codeItems[i].name,
			value: value,
			extend2:codeItems[i].extend2
		};
		for(let t = 0;t<includeOtherPropertys.length;t++){
			let _p = includeOtherPropertys[t];
			item[_p] = codeItems[i][_p];
		}
		target.push(item);
	}
};
```

