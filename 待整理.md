## 字体样式的导入

`main.ts`

```typescript
import './assets/fonts/iconfont.css';
```

`iconfont.css`

```css
@font-face {
  font-family: "iconfont"; /* Project id 2738261 */
  src: url('iconfont.woff2?t=1631240448499') format('woff2'),
       url('iconfont.woff?t=1631240448499') format('woff'),
       url('iconfont.ttf?t=1631240448499') format('truetype');
}

.iconfont {
  font-family: "iconfont" !important;
  font-size: 16px;
  font-style: normal;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.icon-solid-down:before {
  content: "\e62e";
}

...
```



### 路由配置

`routes` 下的一级路由，如果要发挥显示子路由的作用，必须提供一个组件渲染在 `App.vue` 中。

如果一级路由的作用仅仅是用于重定向，而不需要渲染子路由，则可以不提供组件。

```javascript
const routes = [
  {
    path: '/',
    redirect: '/loach',
  },{
    path: '/loach',
    redirect: '/loach/login',
    component: () => import('../views/main.vue'),
    children: [
      {
        path: '/loach/home',
        name: 'Login',
        component: () => import('../views/home/home.vue'),
      }
    ]
  },{
    path: '/loach/login',
    name: 'Login',
    component: () => import('../views/login.vue'),
  }
]
```



### logo制作

```less
<div class="logo">
  <span>共</span><span>沐</span>
  <span>春</span><span class="color-text">鳅</span>
</div>

.logo{
  box-sizing: border-box;
  width: 40px;
  height: 40px;
  font-family:'Courier New', Courier, monospace;
  font-weight: 600;
  color: #fff;
  position: absolute;
  top: 120px;
  right: 220px;
  z-index: 1;
  background: rgba(0, 0, 0, .85);
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  padding: 4px 4px 2px;
  line-height: 1px;
  flex-wrap: wrap;
  vertical-align: bottom;
  span {
    display: inline-block;
  }
  .color-text {
    color: orange;
  }
}
```



### cool动画

> 单纯用过渡，在新窗口打开相同域名时，会有一个样式未归为的bug，估计与内存机制有关。
>
> 故改为使用动画实现。



### 100vw出现滚动条

> 当给元素设置 `width: 100vw` 时，很奇怪的出现了横向滚动条。
>
> 后来将页面（包括其他组件）许多地方的 `100vw` 删除后，消除了该现象。

 

### 引入data中的相对路径

> Vue里动态生成的路径无法被url-loader解析到。

```js
/* 方法一 */
data() {
  return {
  imgUrl: require('@/assets/img/life/light.jpg')
  }  
}

/* 方法二 */
import url from '@/assets/img/life/light.jpg';

data() {
  return {
  imgUrl: url
  }  
}
```



### 引入不带控件的循环视频

`写法一`

```less
<video loop src="@/assets/img/comics/cool-bilibili.webm" autoplay
  width="1728" height="162" 
  style="object-fit: cover; transform: scale(1) translate(0px, 0px) rotate(0deg);"
>
</video>

.animated-banner {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  z-index: -1;
  video {
    width: 100%;
  }
}
```

`写法二`

```react
/* 较旧的版本了 */
<video autoplay loop>
  <source src="@/assets/img/comics/cool-bilibili.webm" type="video/webm">
</video>
```

:whale: 参考自 bilibili，可以通过添加容器控制高度、层级等。



### 组件复用获取元素出错

> 每次获取到的都是文档中首个出现的匹配项，为避免类似错误，要用 `ref` 获取元素。

```react
let wrap = document.querySelector(".home-about-wrap");
wrap.style.color = 'red';   
```



# ----

| --                                          | --                                            |
| ------------------------------------------- | --------------------------------------------- |
| 重点                                        | :star2:                                       |
| 不确定                                      | :question:                                    |
| 次重点                                      | :flipper:                                     |
|                                             | :heavy_check_mark: ​  :heavy_multiplication_x: |
| 拓展、demo                                  | :whale:                                       |
| 密切相关补充                                | :ghost:                                       |
| 存在联系补充                                | :turtle:                                      |
| bug                                         | :octopus:                                     |
| 规范                                        | :hammer_and_wrench:                           |
| 温故                                        | :european_castle:                             |
| 联系上文                                    | :trident:                                     |
| 联系下文                                    | :point_down:                                  |
| `<span style="backGround: pink"></span>`    | 特别注意                                      |
| `<span style="color: slategray"></span>`    | 一般                                          |
| `<span style="color: #a50"></span>`         | 概念化                                        |
| `<span style="color: green"></span>`        | 特别注意                                      |
| `<span style="color: #ed5a65"></span>`      | 名词解释                                      |
| `<span style="backGround: #efe0b9"></span>` | 文件名                                        |



# ----



### flex模拟grid布局

> 模拟一行三项两端对齐，且两项时由左往右开始排。

```less
.feature-list {
  display: flex;
  flex-wrap: wrap;
  width: 100%;
  & span {
    display: inline-block;
    width: 30%;
    margin-right: 5%;
    border: 1px solid #f0f0f0;
  }
  & span:nth-child(3n) {
    margin-right: 0;
  }
}
```



# ----



### RegExp.$1

https://blog.csdn.net/qq_42423964/article/details/102385983

D:\项目相关\uni-app\万宁微商城\manning-cloud-store-app4\src\lib/date.util.js



### Proxy(代理)

**Proxy** 也就是代理，可以[帮助](https://www.jianshu.com/p/77eaaf34e732)我们完成很多事情，例如对数据的处理，对构造函数的处理，对数据的验证，说白了，就是在我们访问对象前添加了一层拦截，可以过滤很多[操作](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，而这些过滤，由你来定义。



#### 语法

```javascript
let p = new Proxy(target, handler);
```

<span style="color: #f7534f;font-weight:600">target  </span>需要使用 <span style="color: #a50">Proxy</span> 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）;

<span style="color: #f7534f;font-weight:600">handler </span>一个配置对象，其属性是当执行一个操作时定义代理的行为的函数（可以理解为某种触发器）。



#### get函数

```javascript
let test = {
  name: "小红"
};
test = new Proxy(test, {
  get(target, key) {
    console.log('获取了getter属性');
    return target[key];
  }
});

// 获取 test 的属性时，触发 get 函数
console.log(test.name);

// 获取了getter属性
// 小红
```

:turtle: 上方的案例，我们首先创建了一个<span style="color: #e63e31">test</span>对象，里面有<span style="color: #e63e31">name</span>属性，然后我们使用<span style="color: #e63e31">Proxy</span>将其包装起来，再返回给<span style="color: #e63e31">test</span>，此时的<span style="color: #e63e31">test</span>已经成为了一个<span style="color: #e63e31">Proxy</span>实例，我们对其的操作，都会被<span style="color: #e63e31">Proxy</span>拦截。



#### set函数

>  咱们再来试试使用`set`来拦截一些操作，并将`get`返回值更改。

```javascript
  let xiaohong = {
    name: "小红",
    age: 15
  };
  xiaohong = new Proxy(xiaohong, {
    get(target, key) {
      let result = target[key];
      //如果是获取 年龄 属性，则添加 岁字
      if (key === "age") result += "岁";
      return result;
    },
    set(target, key, value) {
      if (key === "age" && typeof value !== "number") {
        throw Error("age字段必须为Number类型");
      }
      return Reflect.set(target, key, value);
    }
  });
  console.log(`我叫${xiaohong.name}  我今年${xiaohong.age}了`);
  xiaohong.age = "aa";

// 我叫小红，我今年15岁了
// 报错
```



#### set函数其他返回值方式

```javascript
set(target, key, value) {
  if (key === "age" && typeof value !== "number") {
    throw Error("age字段必须为Number类型");
  }
  target[key] = value;
  return true;
}
```

:ghost: `set`函数必须返回一个`boolean`值（否则会报错），只有返回值为`true`时才表示修改成功。



### 微信小程序返回页面自定义

```
methods: {
  // 默认返回行为
  onBackPress(e) {
    if (this.from) {
      uni.switchTab({
        url: '/pages/index/index_home'
      });
      return true;
    }
  },
},
onLoad(option) {
  this.from = option.from
},
```

可以监听页面的传参，决定是否使用自定义返回；需要返回true

在h5和app生效，但在小程序不生效

```
onUnload(){
  if (this.from) {
    uni.switchTab({
      url: '/pages/index/index_home'
    });
    return true;
  }
}
```

​	

### 笔记

![image-20220423165306052](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20220423165306052.png)

### 第二波

![image-20220423165353150](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20220423165353150.png)
