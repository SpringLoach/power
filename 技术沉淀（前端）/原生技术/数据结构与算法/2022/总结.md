awesome-coding-js： 一个拥有 JavaScript 相关的手写方法、很多算法实现的[网站](https://github.com/ConardLi/awesome-coding-js)

## JavaScript专题

### 实现call、apply、bind

#### call

- 1.判断当前`this`是否为函数，防止` Function.prototype.myCall()` 直接调用
- 2.`context` 为可选参数，如果不传的话默认上下文为 `window`
- 3.为`context` 创建一个 `Symbol`（保证不会重名）属性，将当前函数赋值给这个属性
- 4.处理参数，传入第一个参数后的其余参数
- 5.调用函数后即删除该`Symbol`属性

```javascript
Function.prototype.myCall = function(context = window, ...args) {
  if (this === Function.prototype) { // 防止通过 Function.prototype.myCall 调用
    return undefined
  }
  const fn = Symbol()
  context[fn] = this
  const result = context[fn](...args)
  delete context[fn]
  return result
}
```



#### apply

```javascript
Function.prototype.myApply = function(context = window, args) {
  if (this === Function.prototype) {
    return undefined
  }
  const fn = Symbol()
  context[fn] = this
  let result 
  if (Array.isArray(args)) {
    result = context[fn](...args)
  } else {
    result = context[fn]()
  }
  delete context[fn]
  return result
}
```

> 如果传入的 args 为数字等，直接用展开操作符会报错。



#### bind

- 1.处理参数，返回一个闭包
- 2.判断是否为构造函数调用，如果是则使用`new`调用当前函数
- 3.如果不是，使用 `apply`，将 `context` 和处理好的参数传入

```javascript
Function.prototype.myBind = function(context, ...args1) {
  if (this === Function.prototype) {
    throw new TypeError('error')
  }
  const _this = this
  return function F(...args2) {
    // 判断是否用于构造函数
    if (this instanceof F) {
      return new _this(...args1, ...args2)
    } else {
      return _this.apply(context, args1.concat(args2))
    }
  }
}
```



### 实现instanceof

```javascript
function myInstanceof(target, origin) {
  const proto = target.__proto__;
  if (proto) {
    if (origin.prototype === proto) {
      return true;
    } else {
      return myInstanceof(proto, origin)
    }
  } else {
    return false;
  }
}
```



### 时间复杂度

一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中<span style="color: #ff0000">基本操作重复执行的次数</span>（频度）作为算法的时间复杂度。

没有循环语句，记作`O(1)`，也称为常数阶。只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作`O（n）`，也叫线性阶。

常见的时间复杂度有：

- `O(1)`: Constant Complexity: Constant 常数复杂度
- `O(log n)`: Logarithmic Complexity: 对数复杂度
- `O(n)`: Linear Complexity: 线性时间复杂度
- `O(n^2)`: N square Complexity 平⽅方
- `O(n^3)`: N square Complexity 立方
- `O(2^n)`: Exponential Growth 指数
- `O(n!)`: Factorial 阶乘

[![img](.\img\时间复杂度)](https://camo.githubusercontent.com/121110e17309ee77015992f60e05f4d58efc7c1f0dacb6945cbecc0d40566836/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30382f31392f525334786c63745545516a626b77362e706e67)

### 空间复杂度

一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。

一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。



### forEach VS for

forEach方法中return会跳出本次循环,不会将结果作为函数的返回值
for中break会跳出本次循环
for中return会将结果作为函数的返回值



### 数组结构交换值

```javascript
let a = 3;
let b = 66;
[a, b] = [b, a]

console.log(a, b) // 66 3

const arr = [33, 66];
[arr[0], arr[1]] = [arr[1], arr[0]]

console.log(arr) // [66, 33]
```

:octopus: 前面的代码要记得加上分号结尾，否则解析器会把两行认作是一个整体。



## 排序

### 冒泡排序

循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡（向后移动）。

这样一次循环之后最后一个数就是本数组最大的数。

下一次循环继续上面的操作，不循环已经排序好的数。

优化：当一次循环没有发生冒泡，说明已经排序完成，停止循环。

<span style="backGround: #efe0b9">思想</span>

```javascript
const arr = [10, 9, 3, 2, 50] 

// 由首个元素开始，与下一个元素进行比较，如果当前元素更大，交换
第一轮
  第一次 9 10 3 2 50
  第二次 9 3 10 2 50
  第三次 9 3 2 10 50
  第四次 9 3 2 50 10  // 下一轮时，最后一个（与轮数相同）元素不会参与比较

// 如果有 n 个元素，总共要进行 n-1 轮；
// 如果为第 k 轮，该轮比较次数为 n-k 次。
// 故共有两层循环，第一层为进行的轮数，第二层为当前轮数的比较次数
```

<span style="backGround: #efe0b9">算法</span>

```javascript
function bubbleSort(arr) {
  for(let i = 0; i < arr.length - 1; i++) {
    let complete = false
    for(let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j+1]) {
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
        complete = true
      }
    }
    if (!complete) {
      break
    }
  }
  return arr
}
```

时间复杂度：`O(n2)`

空间复杂度: `O(1)`

稳定性: 稳定



### 插入排序

将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。

插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。

<span style="backGround: #efe0b9">思想</span>

```javascript
// 由第二个元素开始作为目标元素，抽离产生间隙，然后对左侧序列，进行从右往左开始比较，
// 若目标元素更小，比较元素右挪一位，目标元素继续与左侧的元素比较
// 若目标元素更大，插入（由于右挪产生的）间隙，退出该轮比较

// 设有 n 个元素，总共进行 n-1 轮
// 设有 k 轮，每轮最多比较 k 次
```

![插入排序](.\img\插入排序)

<span style="backGround: #efe0b9">算法</span>

```javascript
function insetSort(arr) {
  for(let i = 0; i < arr.length - 1; i++) {
    let target = i + 1
    for(let j = i; j >= 0; j--) {
      if (arr[target] < arr[j]) {
        [arr[target], arr[j]] = [arr[j], arr[target]]
        target = j	
      } else {
        break;
      }
    }
  }
  return arr
}
```

时间复杂度：`O(n2)`

空间复杂度:`O(1)`

稳定性: 稳定



### 选择排序

每次循环选取一个最小的数字放到前面的有序序列中。

<span style="backGround: #efe0b9">思想</span>

```javascript
// 由首个元素开始，作为目标元素，依次与后面的元素比较
// 遇到更小的元素时，替换其为目标元素，继续往后比较

// 设有 n 个元素，总共进行 n-1 轮
// 设有 k 轮，每轮最多比较 n - k 次 （前 k-1 个已经排好序，第 k 个不需要比较）
```

![选择排序](.\img\选择排序)

```javascript
function selectionSort(array) {
  for (let i = 0; i < array.length - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < array.length; j++) {
      if (array[j] < array[minIndex]) {
        minIndex = j;
      }
    }
    [array[minIndex], array[i]] = [array[i], array[minIndex]];
  } 
}
```

时间复杂度：`O(n2)`

空间复杂度: `O(1)`

稳定性: 不稳定



## 字符串

### 替换空格

> 使用 %20 代替空格。

**实现一**

```javascript
function replaceSpace(str) {
  return str.split(' ').join('%20');
}
```

**实现二**

```javascript
function replaceSpace(str) {
  return str.replace(/\s/g,'%20');
}
```

**变换**

> 一个空格 / 连续的空格，都用 %20 代替。

```javascript
function replaceSpace(str) {
  return str.replace(/\s+/g,'%20');
}
```



### 翻转单词顺序

> 输入一个英文句子，翻转句子中单词的顺序。如 hey . man，翻转为 man . hey

```javascript
function ReverseSentence(str) {
  if(!str) {
    return ''
  }
  return str.split(' ').reverse().join(' ');
}
```



### 左旋转字符串

> 把字符串前面的若干个字符转移到字符串的尾部。如 abcde 和 2，输出 cdeab。

```javascript
function LeftRotateString(str, n) {
  if(str && n != null) {
    return (str+str).substr(n, str.length)
  } else {
    return ''
  }
}
```



### 首个只出现一次的字符

<span style="color: #ed5a65">题目</span> 在一个字符串(`0<=字符串长度<=10000`，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回`-1`（需要区分大小写）。



**写法一**

用一个`map`存储每个字符出现的字数

第一次循环存储次数，第二次循环找到第一个出现一次的字符。

时间复杂度`O(n)`、空间复杂度`O(n)`

```javascript
function FirstNotRepeatingChars(str) {
  if (!str) {
    return -1;
  }
  let countMap = {}, targetId;
  const array = str.split('');
  // 存储次数
  array.forEach(item => {
    let count = countMap[item];
    if (!count) {
      countMap[item] = 1;
    } else {
      countMap[item] += 1;
    }
  })
  // 找到第一个出现一次的字符
  array.forEach((item, index) => {
    if (countMap[item] === 1) {
      targetId = index;
    }
  })
  return targetId ? countMap : -1;
},

console.log(this.FirstNotRepeatingChar('kfsnfksnfsaqwlneqqwlenqwln'))
```



**写法二**

使用`js`的`array`提供的`indexOf`和`lastIndexOf`方法

遍历字符串，比较每个字符第一次和最后一次出现的位置是否相同。

`indexOf`的时间复杂度为`O(n)`，所以整体的时间复杂度为O(n2)，空间复杂度为`0`。

```javascript
function FirstNotRepeatingChars(str) {
  if (!str) {
    return -1;
  }
  for (let i = 0; i < str.length; i++) {
    if (str.indexOf(str[i]) === str.lastIndexOf(str[i])) {
      return i;
    }
  }
  return -1;
},
```





## 数组

### 顿号分隔

> 最后一项后面不需要加上顿号。

```javascript
let tagName = ''
data.forEach((item, index, arr) => {
  if (index < arr.length - 1) {
    tagName += item.tag_name + '、' 
  } else {
    tagName += item.tag_name
  }
})
```



### 随机选中

```javascript
let food = this.foodList[Math.floor(Math.random() * this.foodList.length)];
```



### 洗牌算法

**版本一**

```javascript
function shuffle(array) {
  let res = []
  while(array.length > 0) {
    let random = Math.floor(Math.random()*array.length);
    res.push(array[random]);
    array.splice(random, 1);
  }
  return res;
}
```



**版本二**

> 随机数从前面几个数字抽取。

```javascript
function disorder(array) {
  let current = array.length - 1;
  array.forEach(item => {
  let random = Math.floor((current + 1) * Math.random());
    [array[current], array[random]] = [array[random], array[current]];
    current--;
  })
  return array;
}
```

**测试代码**

```javascript
 let arrList = [];

 for(let i = 0; i<100000; i++) {
   let res = disorder([1, 2, 3]);
   arrList.push(res)
 }
 let num1 = 0, num2 = 0, num3 = 0;
 arrList.forEach(item => {
   num1 += item[0];
   num2 += item[1];
   num3 += item[2];
 })
 
 console.log(num1 / arrList.length)
 console.log(num2 / arrList.length)
 console.log(num3 / arrList.length)
```



### 生成最小数字

<span style="color: #ed5a65">题目</span> 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

<span style="color: #ed5a65">例子</span> 例如输入数组`{3，32，321}`，则打印出这三个数字能排成的最小数字为`321323`。

```javascript
function PrintMinNumber(numbers) {
  // 不需要处理的情况
  if (!numbers || numbers.length === 0) {
    return "";
  }
  return numbers.sort(compare).join('');
}

function compare(a, b) {
  // 先拼接而不是相加
  const front = "" + a + b;
  const behind = "" + b + a;
  return front - behind;
}

console.log(this.PrintMinNumber([33, 12, 66, 84]))
```



### 基数前偶数后

<span style="color: #ed5a65">题目</span> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。

设定两个指针

第一个指针start从数组第一个元素出发，向尾部前进

第二个指针end从数组的最后一个元素出发，向头部前进

start遍历到偶数，end遍历到奇数时，交换两个数的位置

当start>end时，完成交换

```javascript
function reOrderArray(arr) {
  if (!Array.isArray(arr) || arr.length === 0) {
    return []
  }
  let start = 0;
  let end = arr.length -1;
  while (start < end) {
    while (arr[start] % 2 === 1) {
      start++;
    }
    while (arr[end] % 2 === 0) {
      end--;
    }
    if (start < end) {
      [arr[start], arr[end]] = [arr[end], arr[start]]
    }
  }
  return arr
},

console.log(this.reOrderArray([234,26,12,235,124,37,12]))
```

> 若需要保证相对顺序不变，则不能用上面的写法，需要让两个指针同时从左侧开始。



### 两数之和

<span style="color: #ed5a65">题目</span> 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

可以假设每种输入只会对应一个答案。但是，不能重复利用这个数组中同样的元素。



使用一个`map`将遍历过的数字存起来，值作为`key`，下标作为值。

对于每一次遍历：

- 取`map`中查找是否有`key`为`target-nums[i]`的值
- 如果取到了，则条件成立，返回。
- 如果没有取到，将当前值作为`key`，下标作为值存入`map`

时间复杂度：`O(n)`

空间复杂度`O(n)`

```javascript
function twoSum(arr, sum) {
  const map = {}
  for (let i = 0; i < nums.length; i++) {
    if (map[target - nums[i]] === undefined) {
      map[nums[i]] = i
    } else {
      return [map[target - nums[i]], i]
    }
  }
  return []
},

console.log(this.twoSum([3, 4, 5, 6, 8, 11], 12))
```



### 三数之和

<span style="color: #ed5a65">题目</span> 给定一个包含 `n` 个整数的数组`nums`，判断 `nums` 中是否存在三个元素`a，b，c` ，使得 `a + b + c = 0 ？`找出所有满足条件且不重复的三元组。



- 1.为了方便去重，我们首先将数组排序
- 2.对数组进行遍历，取当前遍历的数`nums[i]`为一个基准数，遍历数后面的数组为寻找数组
- 3.在寻找数组中设定两个起点，最左侧的`left`(`i+1`)和最右侧的`right`(`length-1`)
- 4.判断`nums[i] + nums[left] + nums[right]`是否等于0，如果等于0，加入结果，并分别将`left`和`right`移动一位
- 5.如果结果大于0，将`right`向左移动一位，向结果逼近
- 5.如果结果小于0，将`left`向右移动一位，向结果逼近

```javascript
function threeSum(arr) {
  const result = [];
  arr.sort((a, b) => a - b);
  arr.forEach((item, index) => {
    // 跳过重复数字
    if (index !== 0 && item === arr[index - 1]) return
    let left = index + 1;
    let right = arr.length - 1;
    while (left < right) {
      const sum = item + arr[left] + arr[right]
      if (sum > 0) {
        right--
      } else if (sum < 0) {
        left++
      } else {
        // 注意push后需要移动指针
        result.push([item, arr[left++], arr[right--]])
      }
      // 跳过重复数字
      while (arr[left] === arr[left - 1]) {
        left++
      }
      while (arr[right] === arr[right + 1]) {
        right--
      }
    }
  })
  return result;
},

const arr = [1, 4, -7, 5, -6, -7, 3]
console.log(66766, this.threeSum(arr))
```



### 和为s的两个数

<span style="color: #ed5a65">题目</span> 输入一个递增排序的数组和一个数字`S`，在数组中查找两个数，使得他们的和正好是`S`，如果有多对数字的和等于`S`，输出两个数的乘积最小的。



- 设定一个小索引`left`，从`0`开始
- 设定一个大索引`right`，从`array.length`开始
- 判断`array[left] + array[right]`的值`s`是否符合条件
- 符合条件 - 返回
- 大于`sum`，`right`向左移动
- 小于`sum`，`left`向右移动
- 若`left=right`，没有符合条件的结果

```javascript
function FindNumbersWithSum(arr, sum) {
  arr.sort((a, b) => a - b)
  if (Array.isArray(arr) && arr.length > 1) {
    let left = 0
    let right = arr.length - 1
    while (left < right) {
      const s = arr[left] + arr[right]
      if (s < sum) {
        left++
      } else if (s > sum) {
        right--
      } else {
        return [arr[left], arr[right]]
      }
    }
  }
  return []
},

const arr = [1, 4, -7, 5, -6, -7, 3]
console.log(66766, this.FindNumbersWithSum(arr, 6))
```



### 扑克牌顺子

<span style="color: #ed5a65">题目</span> 扑克牌中随机抽`5`张牌，判断是不是一个顺子，即这`5`张牌是不是连续的。

`2-10`为数字本身，`A`为`1`，`J`为`11...`大小王可以看成任何数字，可以把它当作`0`处理。



- 1.数组排序
- 2.遍历数组
- 3.若为`0`，记录`0`的个数加`1`
- 4.若不为`0`，记录和下一个元素的间隔
- 5.最后比较`0`的个数和间隔数，间隔数`>0`的个数则不能构成顺子
- 6.注意中间如果有两个元素相等则不能构成顺子

```javascript
function IsContinuouss(arr) {
  if (Array.isArray(arr) && arr.length > 0) {
    arr.sort();
    let kingCount = 0;
    let spaceCount = 0;
    for (let i = 0; i < arr.length - 1; i++) {
      if (arr[i] === 0) {
        kingCount += 1
      } else if (arr[i + 1] - arr[i] > 0) {
        spaceCount += arr[i + 1] - arr[i] - 1;
      } else {
        return false
      }
    }
    return kingCount - spaceCount >= 0
  }
  return false;
},

console.log(this.IsContinuous([4, 6, 7, 8, 5]))
```



### 数组中出现次数过半的元素

<span style="color: #ed5a65">题目</span> 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。



开辟一个额外空间存储每个值出现的次数，时间复杂度最大为O(n)，逻辑简单

```javascript
MoreThanHalfNum(arr) {
  if (Array.isArray(arr) && arr.length > 1) {
    const temp = {}
    let target = 0
    arr.forEach(item => {
      if (!temp[item]) {
        temp[item] = 1
      } else {
        temp[item] += 1
      }
      if (temp[item] > (arr.length / 2)) {
        target = item
      }
    })
    return target
  }
  return 0
},

console.log(this.MoreThanHalfNum([6, 4, 2, 6, 6, 2, 6]))
```



### 连续子数组的最大和

<span style="color: #ed5a65">题目</span> 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值，要求时间复杂度为`O(n)`

<span style="color: #ed5a65">例子</span> 例如:`{6,-3,-2,7,-15,1,2,2}`,连续子向量的最大和为8(从第0个开始,到第3个为止)。



记录一个当前连续子数组最大值 `max` 默认值为数组第一项

记录一个当前连续子数组累加值 `sum` 默认值为数组第一项

1.从数组第二个数开始，若 `sum<0` 则当前的`sum`不再对后面的累加有贡献，`sum = 当前数`

2.若 `sum>0` 则`sum = sum + 当前数`

3.比较 `sum` 和 `max` ，`max = 两者最大值`

```javascript
function FindGreatestSumOfSubArrays(arr) {
  if (Array.isArray(arr) && arr.length > 0) {
    let max = arr[0]
    let sum = arr[0]
    arr.forEach((item, index) => {
      if (index === 0) return
      if (sum < 0) {
        sum = item
      } else {
        sum += item
      }
      if (sum > max) {
        max = sum
      }
    })
    return max
  }
  return 0
},

// const arr = [1, 4, -2, 5, -6, -7, 3]
const arr = [-1, -2 , -3]
console.log(66766, this.FindGreatestSumOfSubArray(arr))
```



## 导出表格相关

### 数组对象-属性的筛选、排序

```javascript
let arrData = [
  { a: '1', b: '2', c: '3' },
  { a: '11', b: '22', c: '33' }
]

let filterKeys = ['c', 'b'];
// 基于filterKeys筛选属性并排序
arrData = arrData.map((item) => filterKeys.reduce((p, k) => ((p[k] = item[k]), p), {}));

console.log(arrData, '结果')
[
  { c: '3', b: '2' },
  { c: '33', b: '22' }
]
```



<span style="color: #ed5a65">拓展</span>：添加表头

```javascript
let arrData = [
  { a: '1', b: '2', c: '3' },
  { a: '11', b: '22', c: '33' }
]

const header = {
  c: '标题三',
  b: '标题二'
}

arrData.unshift(header);
const filterKeys = Object.keys(header)

arrData = arrData.map((item) => filterKeys.reduce((p, k) => ((p[k] = item[k]), p), {}));

console.log(arrData)
[
  { c: '标题三', b: '标题二' },
  { c: '3', b: '2' },
  { c: '33', b: '22' }
]
```



### 对象数组变为二维数组

> 这里没有保留键。

```javascript
const res =  tableData
  // 基于colFilterKeys筛选属性并排序，扁平化数组
  .map((item) => {
    return colFilterKeys.reduce((p, k) => {
      p[k] = Array.isArray(item[k]) ? item[k].toString() : item[k];
      return p;
    }, {});
  })
  // 将对象的所有值取出，作为数组
  .map((item) => Object.values(item)),
```



# --topcode--

### CodeTop刷题情况

:eight_spoked_asterisk: 简单 

:yellow_heart: 中等

:closed_book:  困难

来源： 前端频数最高前一百题

前面40题价值更高，前20题最高。

| 题目                                 | 类别            | 难度                    | 完成     |
| ------------------------------------ | --------------- | ----------------------- | -------- |
| 3.无重复字符的最长子串               | 原生API         | :yellow_heart:          | 2022/9/3 |
| 88.合并两个有序数组                  | 原生API         | :eight_spoked_asterisk: | 2022/9/2 |
| 165. 比较版本号                      | 原生API         | :yellow_heart:          | 2022/9/4 |
| 415. 字符串相加                      | 原生API/...     | :eight_spoked_asterisk: | 2022/9/2 |
| 1. 两数之和                          | 哈希表          | :eight_spoked_asterisk: | 2022/9/2 |
| 20. 有效的括号                       | 栈              | :eight_spoked_asterisk: | 2022/9/2 |
| 46. 全排列                           | 递归            | :yellow_heart:          | 2022/9/4 |
| 102. 二叉树的层序遍历                | 递归/二叉树     | :yellow_heart:          | 2022/9/4 |
| 112. 路径总和                        | 递归/二叉树     | :eight_spoked_asterisk: | 2022/9/4 |
| 70. 爬楼梯                           | 斐波那契数列    | :eight_spoked_asterisk: | 2022/9/2 |
| 53. 最大子序和                       | 动态规划        | :eight_spoked_asterisk: | 2022/9/4 |
| 15. 三数之和                         | 双指针          | :yellow_heart:          | 2022/9/5 |
| 206. 反转链表                        | 链表/指针       | :eight_spoked_asterisk: | 2022/9/5 |
| 141. 环形链表                        | 链表/快慢指针   | :eight_spoked_asterisk: | 2022/9/5 |
| 121. 买卖股票的最佳时机              | 贪心/dp         | :eight_spoked_asterisk: | 2022/9/2 |
| 215. 数组中的第K个最大元元素         |                 | :yellow_heart:          |          |
| 5. 最长回文子串                      | 中心扩散法      | :yellow_heart:          |          |
| 补充题4. 手撕快速排序                |                 | :yellow_heart:          |          |
| 129. 求根到叶子节点数字之和          |                 | :yellow_heart:          |          |
| 200. 岛屿数量                        |                 | :yellow_heart:          |          |
| ---30---                             |                 | :yellow_heart:          |          |
| 704. 二分查找                        |                 | :eight_spoked_asterisk: |          |
| 300. 最长上升子序列                  |                 | :yellow_heart:          |          |
| 21. 合并两个有序链表                 | 链表            | :eight_spoked_asterisk: |          |
| 22. 括号生成                         |                 | :yellow_heart:          |          |
| 104. 二叉树的最大深度                | 递归/二叉树     | :eight_spoked_asterisk: |          |
| 322. 零钱兑换                        |                 | :yellow_heart:          |          |
| 54. 螺旋矩阵                         |                 | :yellow_heart:          |          |
| 94. 二叉树的中序遍历                 | 二叉树          | :eight_spoked_asterisk: |          |
| 146. LRU缓存机制                     |                 | :yellow_heart:          |          |
| 剑指 Offer 22. 链表中倒数第k个节点   | 链表            | :yellow_heart:          |          |
| 42. 接雨水                           |                 | :closed_book:           |          |
| 剑指 Offer 10- I. 斐波那契数         | 斐波那契数      | :eight_spoked_asterisk: |          |
| 695. 岛屿的最大面积                  |                 | :yellow_heart:          |          |
| 103. 二叉树的锯齿形层次遍历          |                 | :yellow_heart:          |          |
| 209. 长度最小的子数组                |                 | :yellow_heart:          |          |
| 56. 合并区间                         |                 | :yellow_heart:          |          |
| 718. 最长重复子数组                  |                 | :yellow_heart:          |          |
| 226. 翻转二叉树                      | 二叉树          | :eight_spoked_asterisk: |          |
| 384. 打乱数组                        |                 | :yellow_heart:          |          |
| 62. 不同路径                         |                 | :yellow_heart:          |          |
| ---50---                             |                 |                         |          |
| 144. 二叉树的前序遍历                | 二叉树          | :eight_spoked_asterisk: |          |
| 25. K 个一组翻转链表                 |                 | :closed_book:           |          |
| 93. 复原IP地址                       |                 | :yellow_heart:          |          |
| 155. 最小栈                          | 实现栈          | :eight_spoked_asterisk: |          |
| 105. 从前序与中序遍历序列构造二叉树  | 二叉树          | :yellow_heart:          |          |
| 剑指 Offer 10- II. 青蛙跳台阶问题    | 斐波那契数/取模 | :eight_spoked_asterisk: |          |
| 160. 相交链表                        | 链表            | :eight_spoked_asterisk: |          |
| 283. 移动零                          | 排序            | :eight_spoked_asterisk: |          |
| 64. 最小路径和                       |                 | :yellow_heart:          |          |
| 14. 最长公共前缀                     |                 | :eight_spoked_asterisk: |          |
| 43. 字符串相乘                       |                 | :yellow_heart:          |          |
| 48. 旋转图像                         |                 | :yellow_heart:          |          |
| 剑指 Offer 62. 圆圈中最后剩下的数字  | ...             | :eight_spoked_asterisk: |          |
| 509. 斐波那契数                      | 斐波那契数      | :eight_spoked_asterisk: |          |
| 199. 二叉树的右视图                  |                 | :yellow_heart:          |          |
| 198. 打家劫舍                        |                 | :yellow_heart:          |          |
| 41. 缺失的第一个正数                 |                 | :closed_book:           |          |
| 151. 翻转字符串里的单词              |                 | :yellow_heart:          |          |
| 2. 两数相加                          |                 | :yellow_heart:          |          |
| 19. 删除链表的倒数第 N 个结点        |                 | :yellow_heart:          |          |
| ---70---                             |                 |                         |          |
| 230. 二叉搜索树中第K小的元素         |                 | :yellow_heart:          |          |
| 24. 两两交换链表中的节点             |                 | :yellow_heart:          |          |
| 71. 简化路径                         |                 | :yellow_heart:          |          |
| 31. 下一个排列                       |                 | :yellow_heart:          |          |
| 122. 买卖股票的最佳时机 II           |                 | :eight_spoked_asterisk: |          |
| 补充题14. 阿拉伯数字转中文数字       |                 | :yellow_heart:          |          |
| 236. 二叉树的最近公共祖先            |                 | :yellow_heart:          |          |
| 252. 会议室                          |                 | :eight_spoked_asterisk: |          |
| 1143. 最长公共子序列                 |                 | :yellow_heart:          |          |
| 剑指 Offer 09. 用两个栈实现队列      | 实现队列        | :eight_spoked_asterisk: |          |
| 349. 两个数组的交集                  | 集合            | :eight_spoked_asterisk: |          |
| 429. N叉树的层序遍历                 |                 | :yellow_heart:          |          |
| 1556. 千位分隔数                     | 字符串          | :eight_spoked_asterisk: |          |
| 124. 二叉树中的最大路径和            |                 | :closed_book:           |          |
| 394. 字符串解码                      |                 | :yellow_heart:          |          |
| 4. 寻找两个正序数组的中位数          |                 | :closed_book:           |          |
| 169. 多数元素                        |                 | :eight_spoked_asterisk: |          |
| 227. 基本计算器 II                   |                 | :yellow_heart:          |          |
| 剑指 Offer 29. 顺时针打印矩阵        |                 | :eight_spoked_asterisk: |          |
| 101. 对称二叉树                      | 二叉树          | :eight_spoked_asterisk: |          |
| ---80---                             |                 |                         |          |
| 498. 对角线遍历                      |                 | :yellow_heart:          |          |
| 468. 验证IP地址                      |                 | :yellow_heart:          |          |
| 剑指 Offer 54. 二叉搜索树的第k大节点 | 二叉树          | :eight_spoked_asterisk: |          |
| 78. 子集                             |                 | :yellow_heart:          |          |
| 113. 路径总和 II                     |                 | :yellow_heart:          |          |
| 补充题23. 检测循环依赖               |                 | :yellow_heart:          |          |
| 153. 寻找旋转排序数组中的最小值      |                 | :yellow_heart:          |          |
| 179. 最大数                          |                 | :yellow_heart:          |          |
| 110. 平衡二叉树                      | 二叉树          | :eight_spoked_asterisk: |          |
| 257. 二叉树的所有路径                | 二叉树          | :eight_spoked_asterisk: |          |
| 16. 最接近的三数之和                 |                 |                         |          |
| 32. 最长有效括号                     |                 | :closed_book:           |          |
| 剑指 Offer 04. 二维数组中的查找      |                 | :eight_spoked_asterisk: |          |
| 503. 下一个更大元素 II               |                 | :yellow_heart:          |          |
| 40. 组合总和 II                      |                 | :yellow_heart:          |          |
| 162. 寻找峰值                        |                 | :yellow_heart:          |          |
| 剑指 Offer 38. 字符串的排列          |                 | :yellow_heart:          |          |
| 214. 最短回文串                      |                 | :closed_book:           |          |
| 242. 有效的字母异位词                |                 | :eight_spoked_asterisk: |          |
| 221. 最大正方形                      |                 | :yellow_heart:          |          |



### 总结

| 分类     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| leetcode | 题目要求将结果保存到参数（数组），如果直接修改引用，判断会有问题 |
| sort     | 数组的 sort 方法默认比较字符串的 unicode 码，在比较负数时会有问题 |
| sort     | 使用 `sort((a, b) => a - b)` 能实现整数的从小到大排序        |
| 常规-arr | 取数组元素时，要注意长度和索引单位之前是差了一个距离的       |
| join     | 数组的 join 方法默认转化的结果会使用逗号分隔                 |



### 无重复字符的最长子串

```javascript
// 存在重复项时，只需移动指针，并无产生更大值
// 如果左指针到当前位置间不存在元素的重复项，s.indexOf(s[i], minIndex) === i
var lengthOfLongestSubstring = function(s) {
  let minIndex = 0
  let ans = 0
  for(let i = 0; i < s.length; i++){
    // 如果左指针到当前位置间存在元素的重复项，移动左指针到首匹索引的后一位
    if(s.indexOf(s[i], minIndex) < i) {
      minIndex = s.indexOf(s[i], minIndex) + 1
    } else {
      // 记录当前更大的值
      ans = Math.max(ans, i - minIndex + 1)
    }
  }
  return ans
};
```





### 合并两个有序数组

| --       | --                                                           |
| -------- | ------------------------------------------------------------ |
| leetcode | 题目要求不需要返回结果，但是改入参的数组，如果直接更改引用，会有问题 |
|          | 先考虑边界，数组1 / 数组2 的有效元素为空                     |
|          | 从头部元素开始，对两个数组的元素进行两两比较                 |
|          | 如果数组1元素target1大于数组2元素target2，将元素target2嵌入数组1; |
|          | 否则数组1的原有元素索引+1                                    |
|          | 情况一：数组1的原有元素，先遍历完，然后将数组2剩余元素push进去 |
|          | 情况二：数组2，先遍历完                                      |

**解法一**

```javascript
var merge = function (nums1, m, nums2, n) {
  if (m === 0) {
    nums1.splice(0, n, ...nums2)
    return
  }
  if (n === 0) {
    return
  }
  let nums1Index = 0
  let nums2Index = 0
  let validIndex = 0
  nums1.length = m
  while (m > nums1Index || n > nums2Index) {
    if (nums1[nums1Index] >= nums2[nums2Index]) {
      nums1.splice(nums1Index++, 0, nums2[nums2Index++])
    } else if (m > validIndex) {
      nums1Index++
      validIndex++
    } else {
      nums1Index++
      nums1.push(nums2[nums2Index++])
    }
  }
}
```



**解法二**

替换掉数组1当中的0，并重新排序

数组的 sort 方法默认比较字符串的 unicode 码，所以比较负数时会有问题

| --   | --                                                           |
| ---- | ------------------------------------------------------------ |
| sort | 数组的 sort 方法默认比较字符串的 unicode 码，所以比较负数时会有问题 |

```javascript
var merge = function (nums1, m, nums2, n) {
  nums1.splice(m, n, ...nums2)
  nums1.sort((a, b) => a - b)
}
```



### 比较版本号

| 分类     | 说明                                            |
| -------- | ----------------------------------------------- |
| 全局方法 | 对于 01， 023 这些字符，Number 方法能够正确转换 |

```javascript
var compareVersion = function(version1, version2) {
  const arr1 = version1.split('.')
  const arr2 = version2.split('.')
  let length = Math.max(arr1.length, arr2.length)
  for(let i = 0; i < length; i++) {
      const x = arr1[i] ? Number(arr1[i]) : 0
      const y = arr2[i] ? Number(arr2[i]) : 0
      console.log(x, y)
      if (x > y) {
          return 1
      }
      if (y > x) {
          return -1
      }
  }
  return 0
};
```



### 字符串相加

```javascript
var addStrings = function(num1, num2) {
    let i = num1.length - 1, j = num2.length - 1, add = 0;
    const ans = [];
    while (i >= 0 || j >= 0 || add != 0) {
        const x = i >= 0 ? num1[i] - '0' : 0;
        const y = j >= 0 ? num2[j] - '0' : 0;
        const result = x + y + add;
        ans.unshift(result % 10);
        add = Math.floor(result / 10);
        i -= 1;
        j -= 1;
    }
    return ans.join('');
};
```

解析

```javascript
var addStrings = function(num1, num2) {
    let i = num1.length, j = num2.length, add = 0;
    const ans = [];
    while (i > 0 || j > 0 || add !== 0) {
        // 需要把单个字符转化为数字类型
        const x = i >= 0 ? +num1[i - 1] : 0;
        const y = j >= 0 ? +num2[j - 1] : 0;
        const result = x + y + add;
        // 余数为当前数
        ans.unshift(result % 10);
        // 是否能进位
        add = Math.floor(result / 10);
        i -= 1;
        j -= 1;
    }
    return ans.join('');
};
```

也可以利用 arr[x] ，x 为负数时结果为 undefined 借助判断。



### 有效的括号

把需要匹配的项放到栈中，如果是匹配项，取栈顶判断。

| --   | --                                 |
| ---- | ---------------------------------- |
| pop  | 对于空数组，pop() 将返回 undefined |

```javascript
var isValid = function(s) {
    if (s.length % 2 != 0) {return false; }
    const stack = [], 
        map = {
            "(":")",
            "{":"}",
            "[":"]"
        };
    for(const x of s) {
        if(x in map) {
            stack.push(x);
            continue;
        };
        if(map[stack.pop()] !== x) return false;
    }
    return !stack.length;
};
```



| --   | --                                                         |
| ---- | ---------------------------------------------------------- |
| 声明 | 能用 const 不用 let                                        |
| 循环 | for 循环中的 return 会打断后面步骤，并作为函数返回值       |
| 循环 | forEach 中的 return 不会打断后面步骤，也不会作为函数返回值 |



### 全排列

| 特性     | 说明                                        |
| -------- | ------------------------------------------- |
| 拷贝数组 | JSON.parse 拷贝比 Array.from 要节省很多内存 |

```javascript
var permute = function(nums) {
  const arrMap = []
  function getValue(nowArr, resArr) {
    if(resArr.length === 1) {
      arrMap.push(nowArr.concat(resArr))
    } else {
      resArr.forEach((res, index) => {
        const newResArr = JSON.parse(JSON.stringify(resArr))
        newResArr.splice(index, 1)
        getValue(nowArr.concat(res), newResArr)
      })
    }
  }
  getValue([], nums)
  return arrMap
};
```



### 二叉树的层序遍历

| 特性   | 说明                           |
| ------ | ------------------------------ |
| 数结构 | 空树可能为 null / undefined ？ |

```javascript
var levelOrder = function(root) {
  if (!root) return []
  const arr = []
  function addValue(currentLevel, node) {
    if (arr[currentLevel]) {
      arr[currentLevel].push(node.val)
    } else {
      arr[currentLevel] = [node.val]
    }
    if (node.left) {
      addValue(currentLevel + 1, node.left)
    }
    if (node.right) {
      addValue(currentLevel + 1, node.right)
    }
  }
  addValue(0, root)
  return arr
};
```



### 路径总和

```javascript
var hasPathSum = function(root, targetSum) {
  if(!root) return false
  function handleValid(node , resSum) {
    if(!node.left && !node.right) {
      return node.val === resSum;
    }
    const left = node.left ? handleValid(node.left, resSum - node.val) : false;
    const right = node.right ? handleValid(node.right, resSum - node.val) : false;
    return left || right
  }
  return handleValid(root, targetSum)
};
```

:turtle: 也可以直接用方法本身递归，而不用内部创建一个方法，但这样形参的名字不便于理解。



### 两数之和

```javascript
var twoSum = function (nums, target) {
  const hash = {}
  for (let i = 0; i < nums.length; i++) {
    if (hash[target - nums[i]] === undefined) {
      hash[nums[i]] = i
    } else {
      return [hash[target - nums[i]], i]
    }
  }
  return []
};
```



### 爬楼梯

当楼梯为三阶以上时，能到当前楼梯的，只有前一格和前两格。

```react
var climbStairs = function (n) {
  // dp[i] 为第 i + 1 阶楼梯有多少种方法爬到楼顶
  // dp[i] = dp[i - 1] + dp[i - 2]
  const dp = [1, 2]
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n - 1]
}
```



### 最大子序列

当某部分总和的值小于 0 时，将不会对后续作出贡献。

```javascript
var maxSubArray = function(nums) {
  let sum = nums[0]
  let max = nums[0]
  for(let i = 1; i < nums.length; i++) {
    sum = sum < 0 ? nums[i] : sum + nums[i]
    max = Math.max(max, sum)
  }
  return max
};
```



### 三数之和

1. 对于长度不足的数组，直接返回结果
2. 对数组进行排序，方便进行指针操作，去重
3. 从遍历元素的右侧元素和末尾元素开始求和操作，期间去重
4. 优化：对于大于零的项无需遍历

```javascript
var threeSum = function(nums) {
  if(nums.length < 3) return []
  const arr = []
  nums.sort((a, b) => a - b)
  for(let i = 0; i < nums.length - 2 && nums[i] <= 0; i++) {
    if (nums[i] === nums[i - 1]) continue
    let left = i + 1;
    let right = nums.length - 1;
    while(left < right) {
      const result = nums[i] + nums[left] + nums[right];
      if (result === 0) {
        arr.push([nums[i], nums[left], nums[right]]);
        while (nums[left] === nums[left + 1]) left++
        while (nums[right] === nums[right - 1]) right--
        left++;
        right--;
      }
      if (result > 0) {
        right--
      }
      if (result < 0) {
        left++
      }
    }
  }
  return arr
};
```



### 反转链表

可以抽象成两个部分：1. 修改当前节点指向；2. 先前节点和当前节点后移。

```javascript
var reverseList = function (head) {
  let current = head;
  let pre = null;
  while(current) {
    // 保留下一个节点
    const nextNode = current.next;
    // 修正当前节点的指针
    current.next = pre;
    // 更替，可以看作两个位置的移动
    pre = current;
    current = nextNode;
  }
  return pre;
};
```



### 环形链表

```javascript
var hasCycle = function(head) {
  let fast = head;
  let slow = head;
  while(fast && fast.next) {
    fast = fast.next.next;
    slow = slow.next;
    if (fast === slow) {
      return true;
    }
  }
  return false;
};
```



### 买卖股票的最佳时机

贪心算法

```javascript
var maxProfit = function(prices) {
    let min = Infinity // 买入的最小值
    let max = 0 // 最大利润
    for (let i = 0; i < prices.length; i++) {
        max = Math.max(max, prices[i] - min) // 对比最大利润，并保存
        min = Math.min(min, prices[i]) // 记录最小值，并保存
    }
    return max
};
```



动态规划

```
动态规划 前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}
```

```javascript
var maxProfit = function (prices) {
  const dp = [0, prices[1] - prices[0]]
  let min = Math.min(prices[0], prices[1])
  for (let i = 2; i < prices.length; i++) {
    dp[i] = Math.max(dp[i - 1], prices[i] - min)
    min = Math.min(min, prices[i])
  }
  return dp[prices.length - 1] > 0 ? dp[prices.length - 1] : 0
};
```



### 最长回文子串

```javascript
var longestPalindrome = function(s) {
    const expend = index => {
        // 首次扩散（该次扩散未经过验证）
        let l = Math.round(index - 1);
        let r = Math.floor(index + 1);

        while (l >= 0 && r < s.length) {
            if (s[l] === s[r]) {
                // 满足条件时，向外扩散（该次扩散未经过验证）
                l -= 1;
                r += 1;
            } else {
                break;
            }
        }

        return [l + 1, r - 1];
    }

    let maxLen = 0;
    let maxLenStr = '';

    for (let i = 0; i < s.length; i += 0.5) {
        const [l, r] = expend(i);
        const str = s.slice(l, r + 1);

        if (str.length > maxLen) {
            maxLen = str.length;
            maxLenStr = str;
        }
    }

    return maxLenStr;
};
```





### 常用翻译

continue

stack 栈



