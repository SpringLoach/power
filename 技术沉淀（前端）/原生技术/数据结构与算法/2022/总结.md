awesome-coding-js： 一个拥有 JavaScript 相关的手写方法、很多算法实现的[网站](https://github.com/ConardLi/awesome-coding-js)

## JavaScript专题

### 实现call、apply、bind

#### call

- 1.判断当前`this`是否为函数，防止` Function.prototype.myCall()` 直接调用
- 2.`context` 为可选参数，如果不传的话默认上下文为 `window`
- 3.为`context` 创建一个 `Symbol`（保证不会重名）属性，将当前函数赋值给这个属性
- 4.处理参数，传入第一个参数后的其余参数
- 5.调用函数后即删除该`Symbol`属性

```javascript
Function.prototype.myCall = function(context = window, ...args) {
  if (this === Function.prototype) { // 防止通过 Function.prototype.myCall 调用
    return undefined
  }
  const fn = Symbol()
  context[fn] = this
  const result = context[fn](...args)
  delete context[fn]
  return result
}
```



#### apply

```javascript
Function.prototype.myApply = function(context = window, args) {
  if (this === Function.prototype) {
    return undefined
  }
  const fn = Symbol()
  context[fn] = this
  let result 
  if (Array.isArray(args)) {
    result = context[fn](...args)
  } else {
    result = context[fn]()
  }
  delete context[fn]
  return result
}
```

> 如果传入的 args 为数字等，直接用展开操作符会报错。



#### bind

- 1.处理参数，返回一个闭包
- 2.判断是否为构造函数调用，如果是则使用`new`调用当前函数
- 3.如果不是，使用 `apply`，将 `context` 和处理好的参数传入

```javascript
Function.prototype.myBind = function(context, ...args1) {
  if (this === Function.prototype) {
    throw new TypeError('error')
  }
  const _this = this
  return function F(...args2) {
    // 判断是否用于构造函数
    if (this instanceof F) {
      return new _this(...args1, ...args2)
    } else {
      return _this.apply(context, args1.concat(args2))
    }
  }
}
```



### 实现instanceof

```javascript
function myInstanceof(target, origin) {
  const proto = target.__proto__;
  if (proto) {
    if (origin.prototype === proto) {
      return true;
    } else {
      return myInstanceof(proto, origin)
    }
  } else {
    return false;
  }
}
```



### 时间复杂度

一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中<span style="color: #ff0000">基本操作重复执行的次数</span>（频度）作为算法的时间复杂度。

没有循环语句，记作`O(1)`，也称为常数阶。只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作`O（n）`，也叫线性阶。

常见的时间复杂度有：

- `O(1)`: Constant Complexity: Constant 常数复杂度
- `O(log n)`: Logarithmic Complexity: 对数复杂度
- `O(n)`: Linear Complexity: 线性时间复杂度
- `O(n^2)`: N square Complexity 平⽅方
- `O(n^3)`: N square Complexity 立方
- `O(2^n)`: Exponential Growth 指数
- `O(n!)`: Factorial 阶乘

[![img](.\img\时间复杂度)](https://camo.githubusercontent.com/121110e17309ee77015992f60e05f4d58efc7c1f0dacb6945cbecc0d40566836/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30382f31392f525334786c63745545516a626b77362e706e67)

### 空间复杂度

一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。

一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。



### forEach VS for

forEach方法中return会跳出本次循环,不会将结果作为函数的返回值
for中break会跳出本次循环
for中return会将结果作为函数的返回值



### 数组结构交换值

```javascript
let a = 3;
let b = 66;
[a, b] = [b, a]

console.log(a, b) // 66 3

const arr = [33, 66];
[arr[0], arr[1]] = [arr[1], arr[0]]

console.log(arr) // [66, 33]
```

:octopus: 前面的代码要记得加上分号结尾，否则解析器会把两行认作是一个整体。



## 排序

### 冒泡排序

循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡（向后移动）。

这样一次循环之后最后一个数就是本数组最大的数。

下一次循环继续上面的操作，不循环已经排序好的数。

优化：当一次循环没有发生冒泡，说明已经排序完成，停止循环。

<span style="backGround: #efe0b9">思想</span>

```javascript
const arr = [10, 9, 3, 2, 50] 

// 由首个元素开始，与下一个元素进行比较，如果当前元素更大，交换
第一轮
  第一次 9 10 3 2 50
  第二次 9 3 10 2 50
  第三次 9 3 2 10 50
  第四次 9 3 2 50 10  // 下一轮时，最后一个（与轮数相同）元素不会参与比较

// 如果有 n 个元素，总共要进行 n-1 轮；
// 如果为第 k 轮，该轮比较次数为 n-k 次。
// 故共有两层循环，第一层为进行的轮数，第二层为当前轮数的比较次数
```

<span style="backGround: #efe0b9">算法</span>

```javascript
function bubbleSort(arr) {
  for(let i = 0; i < arr.length - 1; i++) {
    let complete = false
    for(let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j+1]) {
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
        complete = true
      }
    }
    if (!complete) {
      break
    }
  }
  return arr
}
```

时间复杂度：`O(n2)`

空间复杂度: `O(1)`

稳定性: 稳定



### 插入排序

将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。

插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。

<span style="backGround: #efe0b9">思想</span>

```javascript
// 由第二个元素开始作为目标元素，抽离产生间隙，然后对左侧序列，进行从右往左开始比较，
// 若目标元素更小，比较元素右挪一位，目标元素继续与左侧的元素比较
// 若目标元素更大，插入（由于右挪产生的）间隙，退出该轮比较

// 设有 n 个元素，总共进行 n-1 轮
// 设有 k 轮，每轮最多比较 k 次
```

![插入排序](.\img\插入排序)

<span style="backGround: #efe0b9">算法</span>

```javascript
function insetSort(arr) {
  for(let i = 0; i < arr.length - 1; i++) {
    let target = i + 1
    for(let j = i; j >= 0; j--) {
      if (arr[target] < arr[j]) {
        [arr[target], arr[j]] = [arr[j], arr[target]]
        target = j	
      } else {
        break;
      }
    }
  }
  return arr
}
```

时间复杂度：`O(n2)`

空间复杂度:`O(1)`

稳定性: 稳定



### 选择排序

每次循环选取一个最小的数字放到前面的有序序列中。

<span style="backGround: #efe0b9">思想</span>

```javascript
// 由首个元素开始，作为目标元素，依次与后面的元素比较
// 遇到更小的元素时，替换其为目标元素，继续往后比较

// 设有 n 个元素，总共进行 n-1 轮
// 设有 k 轮，每轮最多比较 n - k 次 （前 k-1 个已经排好序，第 k 个不需要比较）
```

![选择排序](.\img\选择排序)

```javascript
function selectionSort(array) {
  for (let i = 0; i < array.length - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < array.length; j++) {
      if (array[j] < array[minIndex]) {
        minIndex = j;
      }
    }
    [array[minIndex], array[i]] = [array[i], array[minIndex]];
  } 
}
```

时间复杂度：`O(n2)`

空间复杂度: `O(1)`

稳定性: 不稳定



## 字符串

### 替换空格

> 使用 %20 代替空格。

**实现一**

```javascript
function replaceSpace(str) {
  return str.split(' ').join('%20');
}
```

**实现二**

```javascript
function replaceSpace(str) {
  return str.replace(/\s/g,'%20');
}
```

**变换**

> 一个空格 / 连续的空格，都用 %20 代替。

```javascript
function replaceSpace(str) {
  return str.replace(/\s+/g,'%20');
}
```



### 翻转单词顺序

> 输入一个英文句子，翻转句子中单词的顺序。如 hey . man，翻转为 man . hey

```javascript
function ReverseSentence(str) {
  if(!str) {
    return ''
  }
  return str.split(' ').reverse().join(' ');
}
```



### 左旋转字符串

> 把字符串前面的若干个字符转移到字符串的尾部。如 abcde 和 2，输出 cdeab。

```javascript
function LeftRotateString(str, n) {
  if(str && n != null) {
    return (str+str).substr(n, str.length)
  } else {
    return ''
  }
}
```



### 首个只出现一次的字符

<span style="color: #ed5a65">题目</span> 在一个字符串(`0<=字符串长度<=10000`，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回`-1`（需要区分大小写）。



**写法一**

用一个`map`存储每个字符出现的字数

第一次循环存储次数，第二次循环找到第一个出现一次的字符。

时间复杂度`O(n)`、空间复杂度`O(n)`

```javascript
function FirstNotRepeatingChars(str) {
  if (!str) {
    return -1;
  }
  let countMap = {}, targetId;
  const array = str.split('');
  // 存储次数
  array.forEach(item => {
    let count = countMap[item];
    if (!count) {
      countMap[item] = 1;
    } else {
      countMap[item] += 1;
    }
  })
  // 找到第一个出现一次的字符
  array.forEach((item, index) => {
    if (countMap[item] === 1) {
      targetId = index;
    }
  })
  return targetId ? countMap : -1;
},

console.log(this.FirstNotRepeatingChar('kfsnfksnfsaqwlneqqwlenqwln'))
```



**写法二**

使用`js`的`array`提供的`indexOf`和`lastIndexOf`方法

遍历字符串，比较每个字符第一次和最后一次出现的位置是否相同。

`indexOf`的时间复杂度为`O(n)`，所以整体的时间复杂度为O(n2)，空间复杂度为`0`。

```javascript
function FirstNotRepeatingChars(str) {
  if (!str) {
    return -1;
  }
  for (let i = 0; i < str.length; i++) {
    if (str.indexOf(str[i]) === str.lastIndexOf(str[i])) {
      return i;
    }
  }
  return -1;
},
```





## 数组

### 顿号分隔

> 最后一项后面不需要加上顿号。

```javascript
let tagName = ''
data.forEach((item, index, arr) => {
  if (index < arr.length - 1) {
    tagName += item.tag_name + '、' 
  } else {
    tagName += item.tag_name
  }
})
```



### 随机选中

```javascript
let food = this.foodList[Math.floor(Math.random() * this.foodList.length)];
```



### 洗牌算法

**版本一**

```javascript
function shuffle(array) {
  let res = []
  while(array.length > 0) {
    let random = Math.floor(Math.random()*array.length);
    res.push(array[random]);
    array.splice(random, 1);
  }
  return res;
}
```



**版本二**

> 随机数从前面几个数字抽取。

```javascript
function disorder(array) {
  let current = array.length - 1;
  array.forEach(item => {
  let random = Math.floor((current + 1) * Math.random());
    [array[current], array[random]] = [array[random], array[current]];
    current--;
  })
  return array;
}
```

**测试代码**

```javascript
 let arrList = [];

 for(let i = 0; i<100000; i++) {
   let res = disorder([1, 2, 3]);
   arrList.push(res)
 }
 let num1 = 0, num2 = 0, num3 = 0;
 arrList.forEach(item => {
   num1 += item[0];
   num2 += item[1];
   num3 += item[2];
 })
 
 console.log(num1 / arrList.length)
 console.log(num2 / arrList.length)
 console.log(num3 / arrList.length)
```



### 生成最小数字

<span style="color: #ed5a65">题目</span> 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

<span style="color: #ed5a65">例子</span> 例如输入数组`{3，32，321}`，则打印出这三个数字能排成的最小数字为`321323`。

```javascript
function PrintMinNumber(numbers) {
  // 不需要处理的情况
  if (!numbers || numbers.length === 0) {
    return "";
  }
  return numbers.sort(compare).join('');
}

function compare(a, b) {
  // 先拼接而不是相加
  const front = "" + a + b;
  const behind = "" + b + a;
  return front - behind;
}

console.log(this.PrintMinNumber([33, 12, 66, 84]))
```



### 基数前偶数后

<span style="color: #ed5a65">题目</span> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。

设定两个指针

第一个指针start从数组第一个元素出发，向尾部前进

第二个指针end从数组的最后一个元素出发，向头部前进

start遍历到偶数，end遍历到奇数时，交换两个数的位置

当start>end时，完成交换

```javascript
function reOrderArray(arr) {
  if (!Array.isArray(arr) || arr.length === 0) {
    return []
  }
  let start = 0;
  let end = arr.length -1;
  while (start < end) {
    while (arr[start] % 2 === 1) {
      start++;
    }
    while (arr[end] % 2 === 0) {
      end--;
    }
    if (start < end) {
      [arr[start], arr[end]] = [arr[end], arr[start]]
    }
  }
  return arr
},

console.log(this.reOrderArray([234,26,12,235,124,37,12]))
```

> 若需要保证相对顺序不变，则不能用上面的写法，需要让两个指针同时从左侧开始。



### 两数之和

<span style="color: #ed5a65">题目</span> 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

可以假设每种输入只会对应一个答案。但是，不能重复利用这个数组中同样的元素。



使用一个`map`将遍历过的数字存起来，值作为`key`，下标作为值。

对于每一次遍历：

- 取`map`中查找是否有`key`为`target-nums[i]`的值
- 如果取到了，则条件成立，返回。
- 如果没有取到，将当前值作为`key`，下标作为值存入`map`

时间复杂度：`O(n)`

空间复杂度`O(n)`

```javascript
function twoSum(arr, sum) {
  const map = {};
  if (Array.isArray(arr)) {
    for(let i = 0; i < arr.length; i++) {
      if (map[sum - arr[i]] !== undefined) {
        return [map[sum - arr[i]], i];
      } else {
        map[arr[i]] = i;
      }
    }
  }
  return [];
},

console.log(this.twoSum([3, 4, 5, 6, 8, 11], 12))
```



### 三数之和

<span style="color: #ed5a65">题目</span> 给定一个包含 `n` 个整数的数组`nums`，判断 `nums` 中是否存在三个元素`a，b，c` ，使得 `a + b + c = 0 ？`找出所有满足条件且不重复的三元组。



- 1.为了方便去重，我们首先将数组排序
- 2.对数组进行遍历，取当前遍历的数`nums[i]`为一个基准数，遍历数后面的数组为寻找数组
- 3.在寻找数组中设定两个起点，最左侧的`left`(`i+1`)和最右侧的`right`(`length-1`)
- 4.判断`nums[i] + nums[left] + nums[right]`是否等于0，如果等于0，加入结果，并分别将`left`和`right`移动一位
- 5.如果结果大于0，将`right`向左移动一位，向结果逼近
- 5.如果结果小于0，将`left`向右移动一位，向结果逼近

```javascript
function threeSum(arr) {
  const result = [];
  arr.sort((a, b) => a - b);
  arr.forEach((item, index) => {
    // 跳过重复数字
    if (index !== 0 && item === arr[index - 1]) return
    let left = index + 1;
    let right = arr.length - 1;
    while (left < right) {
      const sum = item + arr[left] + arr[right]
      if (sum > 0) {
        right--
      } else if (sum < 0) {
        left++
      } else {
        // 注意push后需要移动指针
        result.push([item, arr[left++], arr[right--]])
      }
      // 跳过重复数字
      while (arr[left] === arr[left - 1]) {
        left++
      }
      while (arr[right] === arr[right + 1]) {
        right--
      }
    }
  })
  return result;
},

const arr = [1, 4, -7, 5, -6, -7, 3]
console.log(66766, this.threeSum(arr))
```



### 和为s的两个数

<span style="color: #ed5a65">题目</span> 输入一个递增排序的数组和一个数字`S`，在数组中查找两个数，使得他们的和正好是`S`，如果有多对数字的和等于`S`，输出两个数的乘积最小的。



- 设定一个小索引`left`，从`0`开始
- 设定一个大索引`right`，从`array.length`开始
- 判断`array[left] + array[right]`的值`s`是否符合条件
- 符合条件 - 返回
- 大于`sum`，`right`向左移动
- 小于`sum`，`left`向右移动
- 若`left=right`，没有符合条件的结果

```javascript
function FindNumbersWithSum(arr, sum) {
  arr.sort((a, b) => a - b)
  if (Array.isArray(arr) && arr.length > 1) {
    let left = 0
    let right = arr.length - 1
    while (left < right) {
      const s = arr[left] + arr[right]
      if (s < sum) {
        left++
      } else if (s > sum) {
        right--
      } else {
        return [arr[left], arr[right]]
      }
    }
  }
  return []
},

const arr = [1, 4, -7, 5, -6, -7, 3]
console.log(66766, this.FindNumbersWithSum(arr, 6))
```



### 扑克牌顺子

<span style="color: #ed5a65">题目</span> 扑克牌中随机抽`5`张牌，判断是不是一个顺子，即这`5`张牌是不是连续的。

`2-10`为数字本身，`A`为`1`，`J`为`11...`大小王可以看成任何数字，可以把它当作`0`处理。



- 1.数组排序
- 2.遍历数组
- 3.若为`0`，记录`0`的个数加`1`
- 4.若不为`0`，记录和下一个元素的间隔
- 5.最后比较`0`的个数和间隔数，间隔数`>0`的个数则不能构成顺子
- 6.注意中间如果有两个元素相等则不能构成顺子

```javascript
function IsContinuouss(arr) {
  if (Array.isArray(arr) && arr.length > 0) {
    arr.sort();
    let kingCount = 0;
    let spaceCount = 0;
    for (let i = 0; i < arr.length - 1; i++) {
      if (arr[i] === 0) {
        kingCount += 1
      } else if (arr[i + 1] - arr[i] > 0) {
        spaceCount += arr[i + 1] - arr[i] - 1;
      } else {
        return false
      }
    }
    return kingCount - spaceCount >= 0
  }
  return false;
},

console.log(this.IsContinuous([4, 6, 7, 8, 5]))
```



### 数组中出现次数过半的元素

<span style="color: #ed5a65">题目</span> 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。



开辟一个额外空间存储每个值出现的次数，时间复杂度最大为O(n)，逻辑简单

```javascript
MoreThanHalfNum(arr) {
  if (Array.isArray(arr) && arr.length > 1) {
    const temp = {}
    let target = 0
    arr.forEach(item => {
      if (!temp[item]) {
        temp[item] = 1
      } else {
        temp[item] += 1
      }
      if (temp[item] > (arr.length / 2)) {
        target = item
      }
    })
    return target
  }
  return 0
},

console.log(this.MoreThanHalfNum([6, 4, 2, 6, 6, 2, 6]))
```



### 连续子数组的最大和

<span style="color: #ed5a65">题目</span> 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值，要求时间复杂度为`O(n)`

<span style="color: #ed5a65">例子</span> 例如:`{6,-3,-2,7,-15,1,2,2}`,连续子向量的最大和为8(从第0个开始,到第3个为止)。



记录一个当前连续子数组最大值 `max` 默认值为数组第一项

记录一个当前连续子数组累加值 `sum` 默认值为数组第一项

1.从数组第二个数开始，若 `sum<0` 则当前的`sum`不再对后面的累加有贡献，`sum = 当前数`

2.若 `sum>0` 则`sum = sum + 当前数`

3.比较 `sum` 和 `max` ，`max = 两者最大值`

```javascript
function FindGreatestSumOfSubArrays(arr) {
  if (Array.isArray(arr) && arr.length > 0) {
    let max = arr[0]
    let sum = arr[0]
    arr.forEach((item, index) => {
      if (index === 0) return
      if (sum < 0) {
        sum = item
      } else {
        sum += item
      }
      if (sum > max) {
        max = sum
      }
    })
    return max
  }
  return 0
},

// const arr = [1, 4, -2, 5, -6, -7, 3]
const arr = [-1, -2 , -3]
console.log(66766, this.FindGreatestSumOfSubArray(arr))
```



## 导出表格相关

### 数组对象-属性的筛选、排序

```javascript
let arrData = [
  { a: '1', b: '2', c: '3' },
  { a: '11', b: '22', c: '33' }
]

let filterKeys = ['c', 'b'];
// 基于filterKeys筛选属性并排序
arrData = arrData.map((item) => filterKeys.reduce((p, k) => ((p[k] = item[k]), p), {}));

console.log(arrData, '结果')
[
  { c: '3', b: '2' },
  { c: '33', b: '22' }
]
```



<span style="color: #ed5a65">拓展</span>：添加表头

```javascript
let arrData = [
  { a: '1', b: '2', c: '3' },
  { a: '11', b: '22', c: '33' }
]

const header = {
  c: '标题三',
  b: '标题二'
}

arrData.unshift(header);
const filterKeys = Object.keys(header)

arrData = arrData.map((item) => filterKeys.reduce((p, k) => ((p[k] = item[k]), p), {}));

console.log(arrData)
[
  { c: '标题三', b: '标题二' },
  { c: '3', b: '2' },
  { c: '33', b: '22' }
]
```



### 对象数组变为二维数组

> 这里没有保留键。

```javascript
const res =  tableData
  // 基于colFilterKeys筛选属性并排序，扁平化数组
  .map((item) => {
    return colFilterKeys.reduce((p, k) => {
      p[k] = Array.isArray(item[k]) ? item[k].toString() : item[k];
      return p;
    }, {});
  })
  // 将对象的所有值取出，作为数组
  .map((item) => Object.values(item)),
```



