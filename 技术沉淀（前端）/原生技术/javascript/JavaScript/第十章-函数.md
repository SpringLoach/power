- [第十章-函数](#第十章-函数)
  + [实例化函数对象](#实例化函数对象)
  + [箭头函数](#箭头函数)
  + [函数名](#函数名)
  + [理解参数](#理解参数)
  + [没有重载](#没有重载)
  + [默认参数值](#默认参数值)
    - 默认参数作用域与暂时性死区
  + [实参展开和形参合并](#实参展开和形参合并)
  + [函数声明与函数表达式](#函数声明与函数表达式)
  + [函数作为值](#函数作为值)
    - 返回另一个函数的执行结果
    - 返回另一个函数
  + [函数内部](#函数内部)
  + [函数属性与方法](#函数属性与方法)
  + [函数表达式](#函数表达式)
  + [尾调用优化](#尾调用优化)
    - 为调用优化的条件
  + [闭包](#闭包)
    - this对象
    - 内存泄漏
  + [立即调用的函数表达式](#立即调用的函数表达式)
    - ES6块级作用域的实现
  + [私有变量](#私有变量)
    - 模块模式
    - 模块增强模式


## 第十章-函数  
> 函数实际上是对象，而函数名是指向函数对象的指针，不一定与函数本身紧密绑定。  

#### 实例化函数对象
```
/* 函数声明 */
function sum(x, y) {return x + y;}

/* 函数表达式 */
let sum = function(x, y) {return x + y;};

/* 箭头函数 */
let sum = (x, y) => {return x + y};

/* 不建议的构造函数 */
let sum = new Function("x", "y", "return x + y");
```

----

#### 箭头函数  

序号 | 特征 
:-: | :-: 
Ⅰ | 有且只有一个参数时，可以不用括号
Ⅰ | 仅一参数，但使用默认参数时，括号不能省
Ⅱ | 省略大括号时，只能带一段代码，且隐性 `return`
Ⅲ | 不能使用 arguments、super、new.target
Ⅳ | 不能用作构造函数、没有 prototype 属性

----

#### 函数名  

```
function sum(x, y) {return x + y;}

/* 给变量赋值对象时，实际上复制的是指向地址的指针 */
let subSum = sum;

/* 解除 sum 对函数的引用 */
sum = null;
subSum(2, 3);  // 5
```

ES6 | 函数对象的 name 属性 
:-: | :-: 
① | 只读，保存函数标识符或空字符串
② | 对于获取、设置、bind()实例化的函数，有前缀

----

#### 理解参数  
> ECMAScript函数不声明命名参数也没关系，同时也不关心传参的个数及参数的类型。如果调用函数时没传对应的参数，它的值就是 `undefined`。  

函数内部的 `arguments` 对象是一个类数组对象，从中可以取得传入函数的每个参数，也可以访问 `arguments.length` 属性获取传参数量。  

序号 | 特征
:-: | :-: 
① | arguments 对象可以和命名参数一起使用
② | 修改 arguments 对象的值，将同步到对应的命名参数
③ | :grey_question: 修改命名参数的值，不会影响 arguments 对象对应的值
④ | arguments 对象在传参数量以外的修改不会反映到命名参数  
⑤ | 严格模式下，不可重写 arguments 对象，改值也不会同步到命名参数  

:snowflake: 箭头函数没有 `arguments` 对象，但可以通过包装函数提供给箭头函数。  

----

#### 没有重载 
> 重载：对于同一个函数，可拥有多个定义。接受参数的类型和数量不同，则（使用的）定义不同。  

----

#### 默认参数值  

ES6 | 默认参数值  
:-: | :-: 
① | 不传参或传 `undefined` 将使用默认参数值
② | 不会影响 `arguments` 对象，仍以调函时传值为准
② | 此时修改命名参数不会影响 `arguments` 对象

:snowflake: 函数x的默认参数可以是调用函数y后的返回值。函数x在定义时不会调用函数y，只有在调用函数x且未传相应参时，函数y才被调用。  

**#默认参数作用域与暂时性死区**

序号 | 特征  
:-: | :-: 
① | 定义多个默认参数相当于使用 let 关键字顺序声明，前参不可用后参赋值
② | 参数存在于自己的作用域，不能引用函数体的作用域

----

#### 实参展开和形参合并  
> [对象展开符](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/实验项.md#实参展开和形参合并)作为形参时，将剩余参数合并为数组；作为实参时，将可迭代对象转化为多个参数。  

用法 | 说明 
:-: | :-: 
命名参数 | 必须作为最后的参数
命名参数 | 将剩余参数合并为数组。无剩余参数时，得到空数组
传参 | 将可迭代对象转化为多个参数  

----

#### 函数声明与函数表达式  
> 函数声明会在代码执行前被读取并添加到执行上下文（作用域），包含于其中的函数定义也被添加到执行上下文。  

序号 | 特征  
:-: | :-: 
函数声明 | 提升，需要函数名称
函数表达式 | 不能提升  

----

#### 函数作为值  
> 可以在一个函数中返回另一个函数。  

**#返回另一个函数的执行结果**  
```
/* 将把第二个参数传递给 Fc 作为参数 */
function callFc(Fc, arg) {
  return Fc(arg);
} 

function add(n) {
  return n + 1;
}

callFc(add, 2);
```

**#返回另一个函数**
> 数组中包含多个对象，创建的函数将根据对象的属性进行排序。  
```
/* 内部函数可以从父级作用域拿到变量 propertyName */
function doComparison(propertyName) {
  return function(obj1, obj2) {
    let v1 = obj1[propertyName];
    let v2 = obj2[propertyName];
    
    if(v1 < v2) {
      return -1;
    } else if (v1 > v2) {
      return 1;
    } else {
      return 0;
    }
  };
} 

let x = [
  {name: 'Hong', age: 19},
  {name: 'Blue', age: 18}
]

/* 每次会传入两个数组元素作为参数 */
x.sort(doComparison('age'));
```

----

#### 函数内部  

类别 | 名称 | 说明 | 版本
:-: | :-: | :-: | :-: 
对象 | arguments | 传参列表，存在于 `function` 定义的函数 | ES5，非严格
属性 | arguments.callee | 指向 arguments 对象所在函数 | ES5，非严格
方法 | arguments.callee() | 调用自身所在函数。**递归**中调用可以与函数名解耦 | ES5，非严格
对象 | this | 标准函数：调用该方法的对象（执行上下文） | ES5
对象 | this | 箭头函数：定义该方法的对象（函数也是对象） | ES5
属性 | caller | `函数名.caller` 引用调用当前函数的函数 | ES5，非严格
属性 | new.target | 检测函数是否用 new 调用，返回 undefined / 被调用的构造函数 | ES6

----

#### 函数属性与方法  

类别 | 说明
:-: | :-: 
length | 函数定义的命名参数的个数
prototype | 保存引用类型的实例属性和方法；不可枚举  
apply() | 指定函数的执行上下文（this），传参
[call()](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#call和apply) | 指定函数的执行上下文，传参
bind() | 返回函数，其中的 this 指向参数对象
toString() | 返回函数的代码，应只在调试中使用
toLocalString() | 同上
valueOf() | 返回函数本身  

----

#### 函数表达式  

名称 | 举栗 | 说明
:-: | :-: | :-: 
匿名函数 | `let sum = function(a, b) {...};` | `function` 关键字后面没有标识符 
匿名函数 | `function sum(){return function() {};}` | 被当作值使用的函数，一定是函数表达式   
命名函数表达式 | `const sum = (function f(a, b) {...});` | 可以在**递归**中调用自身，以避免赋值给其它变量所引起的问题   

----

#### 尾调用优化  
> ES6 新增的内存优化机制，这项优化非常适合“尾调用”，即外部函数的返回值是其某个内部函数的返回值。  

```
function outer() {
  return inner();  // 尾调用
}
```
由于引擎发现函数的逻辑允许基于尾调用将其销毁，此时无论多少层嵌套函数，都只有一个栈帧。  

**#为调用优化的条件**  

序号 | 说明
:-: | :-: 
① | 严格模式
② | 外部函数**直接**返回尾调用函数的调用
③ | 尾调用函数返回给外部函数的值不需要执行额外操作
④ | 尾调用函数不是引用了外部函数作用域中变量的闭包

----

#### 闭包  
> 闭包指的是那些引用了另一个函数作用域中变量的函数，通常在嵌套函数中实现。  

序号 | 原理
:-: | :-: 
① | 函数在执行时会创造作用域链
② | 用 arguments 和其它命名参数初始化自身的活动对象
③ | 作用域链上的第二个对象是其外部函数的活动对象
④ | 向外串包含函数，最终为全局的变量对象   

```
function father(n1) {
  let n2 = 3;
  return function() {
    return n1 + n2  // 引用父函数作用域的两个变量
  }
}

/* 父函数执行完毕后，其执行上下文的作用域链会销毁，
   但它的活动对象（由于匿名函数的引用）仍保留在内存中 */
let son = father(5);

let result = son();

/* 解除对匿名函数的引用，便可销毁父函数的活动对象 */
son = null;
```
:snowflake: 一般来说，变量对象在代码执行期间始终存在，而活动对象只在函数执行期间存在。  

**#this对象**  

内部函数 | 指向
:-: | :-: 
匿名函数 | 不再是执行函数的上下文，而会指向 window
箭头函数 | 仍为定义它的对象（函数）

**#内存泄漏**   
> 在旧版本的IE中，由于垃圾回收机制不同，把 HTML 元素保存在闭包的作用域，就相当于元素不能被销毁。  

```
function handle() {
  let el = document.getElementById('header');
  let id = element.id;
  
  element.onclick = () => console.log(id);
  
  /* 解除对 COM 对象的引用（使箭头函数引用不到它），销毁包含函数的活动对象 */
  element = null
}
```

----

#### 立即调用的函数表达式  
> 指立即调用的匿名函数。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。

```
/* 可以模拟将变量限制在块级作用域中 */

(function() {
  // 块级作用域
})();
```

**#ES6块级作用域的实现**    
```
let divs = document.getElementsByTagName('div');

/* 这里不能用 var，也不能将 let 声明放到外面 */
for(let i = 0; i < 3; i++) {
  divs[i].addEventListener('click', function() {
    console.log(i);
  });
}
```

----

#### 私有变量  
> 任何定义在函数或块中的变量，都可以认为是私有的，均无法在外部访问。  

定义 | 说明
:-: | :-: 
私有变量 | 包括函数参数、局部变量，以及函数内部定义的其它函数
特权方法 | 能够访问函数私有变量的公共方法

在对象上有两种方式通过自定义类型创建特权方法  
1. 构造函数  
    - 把私有变量定义在构造函数中  
    - 创建能访问私有成员的特权方法（闭包）
    - 私有变量对于每个实例都是独一无二的  
    - 缺点是每个实例都会重新创建一遍新方法  

2. 静态私有变量  
    - 通过[立即调用的函数表达式](#立即调用的函数表达式)创建私有作用域  
    - 为了给外部访问到，使用全局声明构造函数
    - 将特权方法（闭包）定义到构造函数的原型上，能更好重用代码  
    - 缺点是每个实例都没有了自己的私有变量  

**#模块模式**  
> 将公共属性和方法保存在单例对象中。  

```
let single = function() {
  // 私有变量和私有函数  
  let num = 10;
  
  function verify() {
    return true
  }
  
  // 特权/共有方法和属性  
  return {
    public: true,
    getVerify() {return verify();}
  }
}();
```
:palm_tree: 单例对象：只有一个实例的对象，通过对象字面量创建。  

**#模块增强模式**  
> 适合的场景：单例对象需要是某个特定类型的实例，但又必须给它添加额外属性和方法。  

```
let single = function() {
  // 私有变量和私有函数
  let num = 10;
  
  function verify() {
    return true
  }
  
  // 创建特定类型的对象
  let obj = new anyType();
  
  // 特权/共有方法和属性 
  obj.public = true;
  obj.getVerify = function() {return verify();} 
    
  // 返回对象  
  return obj;
}();
```

## 第十一章-期约与异步函数  

### 异步编程  
> JavaScript使用的单线程事件循环模型。不想因为等待某个操作而阻塞线程执行时，就可以执行异步操作。  

**#以往的异步编程模式**  
> 需要消费异步操作的结果时，通常给异步操作提供一个回调，并使用异步返回的结果作为参数。  

----

### 期约  
> ES6新增的引用类型 Promise，可以通过 new 操作符来实例化。创建新期约时需要传入执行器函数作为参数。  

```
let p = new Promise(() => {});
```

#### 期约基础

**#期约对象的状态**  

私有状态 | 翻译 | 说明 | 落定状态接受值
:-: | :-: | :-: | :-: 
pending | 待定 | 尚未开始/正在执行 | 非落定状态
resolved | 兑现 | 成功 | 值
rejected | 拒绝 | 失败 | 理由

**#执行函数**  

功能 | 说明
:-: | :-: 
初始化期约的异步行为 | 执行函数是**同步**执行的  
控制状态的最终转变 | 传参 `resolve` 和 `reject`，在函数内调用以进入落定状态

:snowflake: 无论落定为哪种状态都是不可逆的。  

**#Promise.resolve()**  
> 通过调用 `Promise.resolve()` 静态方法，可以实例化一个解决的期约（直接为落定状态）。  

参数 | 说明 | 返回值
:-: | :-: | :-: 
期约 | 空包装，自身全等于该期约 | 该期约状态  
非期约值 | 转换为解决值 | `Promise <resolved>: 非期约值`  
不传参 | 解决值为 undefined | `Promise <resolved>: undefined`  

:snowflake: 传入方法的第一个参数，如果不是期约，便会被视作解决值。

**#Promise.reject()**  
> 与前面的方法类似。会抛出一个异步错误，故不能通过 try/catch 捕获，只能由拒绝处理程序捕获。    

参数 | 说明
:-: | :-: 
任何值 | 转化为拒绝的理由  
不传参 | 解决为 undefined 

:snowflake: 拒绝期约的错误不会抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理。  

#### 期约的实例方法  
> 这些方法可以访问异步操作返回的数据，并在**异步操作**中进行处理。  

**#then()**

参数 | 说明 | 更多
:-: | :-:  | :-: 
参数一 | 解决期约的处理程序 | 不想提供时，传入 null 
参数二 | 拒绝期约的处理程序 | 可选

:snowflake: 这个方法本身也返回一个期约。    

**#方法的返回值**    
> 方法会调用对应的处理程序，并通过 `Promise.resolve()` 包装处理程序中的返回值，返回新的期约。

相应的处理程序 | 处理程序中 | 包装
:-: | :-: | :-: 
无 | / | 返回 *上一个期约的状态*
√ | 无显性返回值 | undefined
√ | 有显性返回值 | 返回值 
√ | 返回期约 | 期约  
√ | 返回错误值 | 错误对象
√ | 抛出异常 | 返回 *拒绝的期约*

**#catch()**  
> 接收 onResovled 处理程序，返回新的期约。  

**#finally()**  
> 接收的处理程序在期约转换为解决或拒绝状态时都会执行，返回新的期约。  

处理程序 | 处理程序中 | 返回值
:-: | :-: | :-: 
无 | / | 返回 *上一个期约的状态*
√ | 无显性返回值 | 返回 *上一个期约的状态*
√ | 有显性返回值 | 返回 *上一个期约的状态*
√ | 返回待定期约 | 返回期约的状态
√ | 返回拒绝期约 | 返回期约的状态
√ | 抛出异常 | 返回 *拒绝的期约*  

**#非重入期约方法**   
> 当期约进入落定状态时，相关的处理程序会被排期（推进消息队列），并在当前线程上的同步代码执行完成后才开始执行。  

**#邻近处理程序的执行顺序**  
> 给同一个期约实例添加多个处理程序时，按添加顺序依次执行。  

**#传递解决值和拒绝理由**  

流程 | 方式 
:-: | :-: 
传递 | 作为执行函数中 `resolve()` 或 `reject()` 的第一个参数 
接收 | 作为处理程序的唯一参数  

**#拒绝期约与拒绝错误处理**  
> 在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。  

环境 | 抛出错误的方式 
:-: | :-: 
执行函数 | 在同步抛出错误：期约落定前，可以使用 try/catch 捕获
处理程序 | 在异步抛出错误：错误会从消息队列中异步抛出，不会阻止接下来同步操作的执行

拒绝处理程序在捕捉错误后要将其隔离，同时不影响正常逻辑执行。故拒绝处理程序的任务是在捕获异步错误之后返回一个解决的期约。

#### 期约连锁与期约合成  

**#期约连锁**    
```
/* 将期约逐个串联 */
let p = new Promise((res,rej) => {
  console.log(1);
  res();
}).then(() => console.log(2))
  .then(() => console.log(3))
  .then(() => console.log(4))
 
console.log('a');
// 1 a 2 3 4
```

**#Promise.all()**    
> 该静态方法必须接受一个可迭代对象。待所包含的一组期约全部落定后，返回新的期约。  

```
Promise.all([
  Promise.resolve(),
  Promise.resolve()
]);

// 将可迭代对象中的元素通过 Promise.resolve() 转换为期约  
Promise.all([2, 3]);

// 空的可迭代对象等价于 Promise.resolve()  
Promise.all([]);
```

包含期约 | 合成期约的状态 | 解决值/拒绝理由 
:-: | :-: | :-: 
任一包含期约拒绝 | 拒绝 | 首个拒绝期约的理由
任一包含期约待定 | 待定 | /
所有包含期约解决 | 解决 | 包含所有期约解决值的数组

:snowflake: 添加拒绝处理程序后，包含期约的剩余拒绝都会被静默处理。  

**#Promise.race()**  
> 该静态方法必须接受一个可迭代对象，其中的任一期约落定后，将其包装并返回新的期约。  

```
// 空的可迭代对象等价于 new Promise(() => {}) 
Promise.race([]);

// 其它与 Promise.all() 相似
```

:snowflake: 添加拒绝处理程序后，包含期约的剩余拒绝都会被静默处理。  

**#串联期约的合成**  

```
function compose(...fns) {
  /* 返回一个方法 */
  return (x) => fns.reduce((promise, fn) => promise.then(fn), Promise.resolve(x))
}

function a(x) {}
function b(x) {}
let useCom = compose(a, b);
useCom(233)
```

#### 期约扩展  
> 扩展 ES6 不支持的特性。  

**#期约取消**    
> 本质是给期约解决加一个延时，在这段时间内可以将延时取消掉，从而使期约处于待定状态。需要一些技巧将取消延时的操作暴露在外。  P345 

**#期约进度通知**  

### 异步函数  
> 即 `async/await`，为 ES8 规范新增，能够以同步方式写的代码能够异步执行。  

**#async**  
> 该关键字用于声明异步函数。可以用在函数声明、函数表达式、箭头函数和方法上。  

- 异步函数用有普通函数的正常行为，处于**同步操作**中。  
- 函数内部用 `return` 返回的值会被 `Promise.resolve()` 包装成一个期约对象。 
- 函数内部用 `return` 返回的实现了 thenable 接口的对象，可以提供给处理程序 “解包”。
- 函数内部没有使用 `return` 时，将 undefined 包装为期约对象。  
- （没有 return 的）拒绝期约的错误不会被异步函数捕获。  

**#await**  
> 该关键字必须在异步函数中使用，它会将自身所处的表达式及后面的代码暂停，并退出异步函数去执行其它同步操作。待其后的值可用了，会向任务队列中添加任务。  

- 其后的值会被包装成一个解决的期约，然后整体变为解决值。  
- 其后的值如果是实现了 thenable 接口的对象，由 awit “解包”。  
- 其后的值若是错误的同步操作，异步函数会返回拒绝的期约。  
- 其后的值若是拒绝的期约，异步函数会将拒绝期约返回（不给它添加错误处理程序会报错）。    

```
async function foo() {
  console.log(1);
  console.log(await 3);
  console.log(4);
}
 
foo().catch(console.log);
console.log(2)
// 1 2 3 4
```

**#await的限制**    
> await 关键词不允许出现在同步函数中，不能嵌套到异步函数的同步函数内部，也不能出现在箭头函数中。  

#### 异步函数策略  

**#实现sleep()**  
> 可以通过该函数来实现对程序（函数）的非阻塞的暂停。  

**#利用平行执行**  

```
async function foo() {
  
  /* 先初始化再赋值 */
  const p1 = new Promise(res => setTimeout(res, 200));
  const p2 = new Promise(res => setTimeout(res, 100));
  
  /* 暂停，求值后（这里不需要）添加到任务队列 */
  await p1;
  /* 暂停，求值后（这里不需要）添加到任务队列 */
  await p2;
}

foo();  // 大概需要 204 毫秒
```

**#串行执行期约**  
> 通过串行执行期约将期约的值传递给后续的期约。  

**#栈追踪与内存管理**  
> 栈追踪信息应该直接地表现 JS 引擎当前占内存中函数调用之间的嵌套关系。  

- 创建期约时，调用栈被尽可能地保留，会占用更多的内存。  
- 使用异步函数时则不会有这样的问题。      

## 第十二章-BOM

### window对象  
> BOM 的核心是 window 对象，表示浏览器的实例。网页中定义的所有对象、变量和函数都以 window 作为其 Global 对象。  

- 通过 var 声明的所有全局变量和函数都会变成 window 对象的属性和方法。  
- 使用 let 或 const，则不会把变量添加给全局对象。  
- 访问未声明的变量会抛错，但可以在 window 对象上查询变量是否声明（undefined）   
- 但凡暴露在全局作用域中的对象，都是 window 对象的属性，如 location、navigator。  

#### 窗口关系  

对象 | 指向
:-: | :-: 
top | 最外层窗口，即浏览器窗口  
parent | 当前窗口的父窗口。当前窗口是最外层窗口时，自身等于 top
self | window 对象

:palm_tree: 这些都是 window 对象的属性。  

#### 窗口位置与像素比  

属性/方法 | 说明
:-: | :-: 
screenLeft | 窗口相对于屏幕左侧的位置，单位为 px 
screenTop | 窗口相对于屏幕顶部的位置，单位为 px 
moveTo() | 接受的参数表示要移动到的新位置的绝对坐标 x 和 y
moveBy() | 接受的参数表示相对于当前位置移动的 px  
devicePixelRatio | 表示物理像素与逻辑像素之间的缩放系数  

:palm_tree: 移动窗口的方法可能会被一些浏览器禁用。  

#### 窗口大小  

属性/方法 | 说明
:-: | :-: 
outerWidth、outerHeight | 返回浏览器窗口自身的大小
innerWidth、innerHeight | 返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）
[document.documentElement.clientWidth](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/第十三章-客户端检测.md#客户端尺寸)、.. | 返回页面视口的宽度和高度  
resizeTo() | 接受的参数表示要缩放到的绝对值
resizeBy() | 接受的参数表示要缩放的增加值

:palm_tree: 缩放窗口的方法可能被禁用，同样，也只能应用到最上层的 window 对象。

设备 | 属性/方法 | 说明
:-: | :-: | :-: 
移动设备 | innerWidth、innerHeight | 返回屏幕可见视口的大小
Mobile Internet Explorer | document.documentElement.clientWidth、.. | 返回屏幕可见视口的大小
其它移动设备 | document.documentElement.clientWidth、.. | 返回布局视口的大小（渲染页面的实际大小）
Mobile Internet Explorer | document.body.clientWidth、.. | 返回布局视口的大小（渲染页面的实际大小）

:snowflake: 在缩放页面时，这些值也会相应变化。    
:whale2: 确定页面视口大小 P363 

#### 视口位置  

属性/方法 | 说明 | 参数
:-: | :-: | :-: 
pageXoffset、pageYoffset | 返回文档相对于视口的滚动距离 | /
scrollX、scrollY | 同上 | /
scrollTo() | 相对视口滚动页面的距离，绝对值 | 可接两参，也可接受字典设置平滑
scroll() | 同上 | 同上
scrollBy() | 相对当前视口滚动页面的距离，相对值 | 同上  

#### 导航与打开新窗口  

`window.open()` 方法可以导航到指定 URL，也可以打开新浏览器窗口

参数 | 说明 | 补充
:-: | :-: | :-: 
① | 要加载的 URL | /
② | 目标窗口 | 如果不是已有窗口，就会打开一个新窗口并命名
③ | 新窗口的配置 | 特性字符串。打开的不是新窗口则忽略该参数
④ | 在历史记录替代当前加载页面 | 布尔值  

该方法返回对新建窗口的引用，可以用这个对象操纵新打开的窗口  

属性/方法 | 说明
:-: | :-: 
resizeTo() | 缩放
moveTo() | 移动
close() | 关闭
closed | 是否关闭 
opener | 指向调用 `window.open()` 打开它的窗口  
opener | 将其设置为 null，表示切断通信    

**#安全限制**  

- 不同的浏览器都禁用了部分功能，因此对新窗口的配置可能无效。  
- 浏览器在用户操作下才允许创建弹窗，在页面加载中调用无效。

**#弹窗屏蔽程序**  
> 所有浏览器都内置的屏蔽弹窗的程序，以及一些浏览器拓展都能屏蔽弹窗，需要用不同的方法检测。  

#### 定时器  

方法 | 说明 | 参1 | 参2 | 之后的参数
:-: | :-: | :-: | :-: | :-: 
setTimeout() | 在一段时间后执行的代码 | 函数 | 毫秒数，等待后将任务添加到队列 | 将传递给函数
clearTimeout() | 取消超时任务。任务执行后调用无效 | 上面方法的返回值，超时ID | / | /
setInterval() | 每隔一段时间执行的代码 | 函数 | 毫秒数，等待后将任务添加到队列 | 将传递给函数
clearInterval() | 取消超时任务。任务执行后调用无效 | 上面方法的返回值，超时ID | / | / 

:snowflake: 所有超时执行的代码都会在全局作用域中的一个匿名函数中允许，标准函数（非严格）中的 `this` 指向 window。  
:bug: 不建议在生产环境使用 `setInterval()`，无法保证任务执行的间隔时间。  

#### 系统对话框  
> 由浏览器调用，与网页无关、无法设置样式，外观由操作系统或浏览器决定。由于是同步执行的，它们显示时，代码会停止执行。  

属性/方法 | 类型 | 说明 | 参数 |返回值
:-: | :-: | :-: | :-: | :-:
alert() | 警告框 | 只能关闭 | 自动 toString() | /
moveTo() | 确认框 | 可以确认和取消 | 自动 toString() | 布尔值，可根据其添加操作
prompt() | 提示框 | 可以确认和取消 | 显示文本、默认文本 | 用户输入/null
find() | 查找 | / | 难以利用 | /
print() | 打印 | / | 难以利用 | /

:snowflake: 脚本中有两个以上系统对话框时，第二个以后的对话框都会显示一个是否禁用后续弹窗的复选框。  

### location对象  
> 保存着当前加载文档的信息和把 URL 解析为离散片段的信息。该对象既是 window 的属性，也是 document 的属性。

部分属性 | 说明
:-: | :-: 
hash | `#` 开头的散列值/空字符串
href | 当前加载页面的完整 URL
search | `？` 开头的查询字符串

:snowflake: 修改除 `hash` 外的属性，会导致页面重新加载新 URL。  
:snowflake: 均会增加历史记录。  

#### 查询字符串  
> 要想逐个访问每个查询参数，可以自行设置函数将其取出，也可以利用 URLSearchParams 这个类对查询字符串执行相应操作。  

#### 操作地址  

部分属性 | 使用 | 效果 | 说明
:-: | :-: | :-: | :-: 
location.assign() | 字符串参数 | 导航 | 新增历史记录
window.location | 赋值字符串 | 导航 | 新增历史记录
location.href | 赋值字符串 | 导航 | √新增历史记录
location.replace() | 字符串参数 | 导航 | 不会新增历史记录
location.reload() | 无参/true | 刷新 | 争取从缓存加载/从服务器加载

### navigator对象  
> 该对象通常用于确定浏览器的类型。  

#### 检测插件  

方式 | 适用范围
:-: | :-: 
navigator.plugins | 其它浏览器
ActiveXObject | IE10及更低版本

#### 注册处理程序  
> `navigator.registerProtocolHandler()` 这个在 HTML5 定义的方法，可以把一个网站注册为处理某种特定类型信息应用程序。 

### screen对象  
> 保存浏览器窗口外面的 客户端显示器 的信息，如像素宽度和高度，很少用到。  

### history对象  
> 表示当前窗口使用以来用户的导航历史记录。  

#### 导航  

方法 | 参数 | 说明
:-: | :-: | :-: 
go() | 整数/字符串 | 前进（后退）多少页/导航到历史中包含该字符串的最近的位置
back() | / | 后退一页
forward() | / | 前进一页
length | / | 历史记录的数量

:snowflake: 将 `location.hash` 设置一个新值时，历史记录中会新增一条记录，单页应用程序框架经常用到。  

#### 历史状态管理  

**#history.pushState()方法**  
> 改变浏览器 URL 而不会加载页面，状态信息会被推到历史记录。  

方法 | 参数 | 说明
:-: | :-: | :-: 
参1 | state 对象 | 包含正确初始化页面状态所必须的信息
参2 | 新状态的标题 | /
参3 | （可选的）相对URL | /

**#相关的方法**  

属性/方法 | 说明 
:-: | :-: 
history.state | 获取当前的状态对象
history.replaceState() | 更新状态对象，接受 `pushState()` 同样的前两个参数，不会创建历史记录

**#相关的事件**

事件 | 机制 | 说明
:-: | :-:  | :-:
hashchange | 页面 URL 的散列值变化时触发 | P528
popstate | 使用 `pushState()` 并后退时触发 | 对应的事件对象有一个 `state` 属性










