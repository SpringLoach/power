### 基本骨架

文件结构：

```elm
- views
  + login
    - login.vue
    - hooks
    - config
      + account-config.ts
    - components
      + login-panel.vue
      + login-account.vue
      + login-phone.vue
```

:hammer_and_wrench: 对于依赖 ref/reactive/useStore/onMounted 这些方法的逻辑，抽离到 hooks，否则抽离到 config 中。



### 初始架构

<span style="backGround: #efe0b9">views/login/login.vue</span>

```vue
<template>
  <div class="login">
    <login-panel />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import LoginPanel from './components/login-panel.vue'

export default defineComponent({
  components: {
    LoginPanel
  },
  setup() {
    return {}
  }
})
</script>
```



<span style="backGround: #efe0b9">views/login/components/login-panel.vue</span>

```vue
<template>
  <div class="login-pannel">
    <h1 class="title">后台管理系统</h1>
    <el-tabs v-model="currentTab" stretch>
      <el-tab-pane name="account">
        <!-- 自定义标签插槽 -->
        <template #label>
          <span><i class="el-icon-user-solid"></i> 账号登录</span>
        </template>
		<!-- 默认内容插槽 -->
        <login-account />
      </el-tab-pane>
      <el-tab-pane label="手机登录" name="phone">
        <template #label>
          <span><i class="el-icon-mobile-phone"></i> 手机登录</span>
        </template>
        <login-phone />
      </el-tab-pane>
    </el-tabs>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'
import LoginPhone from './login-phone.vue'
import LoginAccount from './login-account.vue'

export default defineComponent({
  components: {
    LoginPhone,
    LoginAccount
  },
  setup() {
    const currentTab = ref('account') // ①

    return {
      currentTab
    }
  }
})
</script>
```

:ghost: 传入初始值，相当于使用默认类型推导。

:european_castle: 使用 `#label` 作为自定义插槽的标志。



### 规则的导入及表单验证

<span style="backGround: #efe0b9">login-account.vue</span>

```vue
<template>
  <div class="login-account">
    <el-form :model="account" label-width="60px" :rules="rules" ref="formRef">
      <el-form-item label="账号" prop="name">
        <el-input v-model="account.name" />
      </el-form-item>
      <el-form-item label="密码" prop="password">
        <el-input v-model="account.password" />
      </el-form-item>
    </el-form>
  </div>
</template>

<script lang="ts">
import { defineComponent, reactive, ref } from 'vue'
import { rules } from '../config/account-config'
import { ElForm } from 'element-plus'

export default defineComponent({
  setup() {
    const account = reactive({
      name: '',
      password: ''
    })
    const formRef = ref<InstanceType<typeof ElForm>>()
    setTimeout(() => {
      console.log(formRef.value?.validate((valid) => console.log(valid)))
    }, 5000)
    return {
      account,
      rules,
      formRef
    }
  }
})
</script>
```

:hammer_and_wrench: 引入vue方法的顺序： defineComponent、 reactive、 ref

:turtle: 引入的规则，可以直接在 setup 中返回供模板使用，且不需要响应式处理

:turtle: 引用组件时，如果传 const formRef = ref()，相当于any类型，操作时不会有安全检测

:ghost: 引用组件类型时，通过 `<InstanceType<typeof Component>>`  的格式获取

:turtle: 由于 formRef.value 不一定存在，所以用可选链



<span style="backGround: #efe0b9">views/login/config/account-config.ts</span>

```javascript
// 编写好规则
export const rules = {
  name: [
    {
      required: true,
      message: '请输入用户名',
      trigger: 'blur'
    },
    {
      pattern: /^[a-z0-9]{5,10}$/,
      message: '用户名必须是5~10个字母或者数字',
      trigger: 'blur'
    }
  ],
  password: [
    {
      required: true,
      message: '请输入密码',
      trigger: 'blur'
    },
    {
      pattern: /^[a-z0-9]{3,}$/,
      message: '密码必须是3位以上的字母或者数字',
      trigger: 'blur'
    }
  ]
}
```

:hammer_and_wrench: 对于依赖 ref/reactive/useStore/onMounted 这些方法的逻辑，抽离到 hooks，否则抽离到 config 中。



### utils-缓存

```javascript
class LocalCache {
  setCache(key: string, value: any) {
    if (value === undefined) return  // 无法作为字符串解析
    window.localStorage.setItem(key, JSON.stringify(value))
  }

  getCache(key: string) {
    const value = window.localStorage.getItem(key)
    if (value) {
      return JSON.parse(value)
    }
  }

  deleteCache(key: string) {
    window.localStorage.removeItem(key)
  }

  clearCache() {
    window.localStorage.clear()
  }
}

export default new LocalCache()
```

类比函数更具有可扩展性，在导出时可以实例化类。

由于缓存值只接受字符串形式，故需要通过 JSON 字符串化处理。



### 接口

<span style="backGround: #efe0b9">service/login/login.ts</span>

```javascript
import baseRequest from '../index'

import { IAccount, IDataType, ILoginResult } from './type'

enum LoginAPI {
  AccountLogin = '/login',
  LoginUserInfo = '/users/', // 用法: /users/1
  UserMenus = '/role/' // 用法: role/1/menu
}

export function accountLoginRequest(account: IAccount) {
  return baseRequest.request<IDataType<ILoginResult>>({
    method: 'POST',
    url: LoginAPI.AccountLogin,
    data: account
  })
}

export function requestUserInfoById(id: number) {
  return baseRequest.request<IDataType>({
    method: 'GET',
    url: LoginAPI.LoginUserInfo + id
  })
}

export function requestUserMenusByRoleId(id: number) {
  return baseRequest.request<IDataType>({
    method: 'GET',
    url: LoginAPI.UserMenus + id + '/menu'
  })
}
```

<span style="backGround: #efe0b9">service/login/type.ts</span>

```
export interface IAccount {
  name: string
  password: string
}

export interface ILoginResult {
  id: number
  name: string
  token: string
}

export interface IDataType<T = any> {
  code: number
  data: T
}
```

可以复制响应数据，在[辅助网站](http://www.json2ts.com/)自动生成类型

但对于复杂数据结构，存在出错可能；另外手动配置可选值也麻烦，故可以给它一个 any 的默认类型。



#### 跨域解决

<span style="backGround: #efe0b9">vue.config.js</span>

```javascript
module.exports = {
  devServer: {
    proxy: {
      '^/api': {
        target: 'http://demo:6666',
        pathRewrite: {
          '^/api': ''
        },
        changeOrigin: true
      }
    }
  },
}
```

<span style="backGround: #efe0b9">service/request/config.ts</span>

```javascript
const condition = 1

let BASE_URL: string, BASE_NAME: string

if (condition === 1) {
  BASE_URL = '/api'  // 改动
} else if (condition === 2) {
  BASE_URL = 'http://demo/prod'
}

const TIME_OUT = 10000

export { BASE_URL, TIME_OUT }
```



#### 携带token

<span style="backGround: #efe0b9">src/service/request/index.ts</span>

```javascript
import localCache from '@/utils/cache'

class Request {
  ...
  constructor(options: AxiosRequestConfig) {
    ...
    this.instance.interceptors.request.use(
      (config) => {
        const token = localCache.getCache('token')
        if (token) {
          if (!config.headers) {
            config.headers = {}
          }
          config.headers.Authorization = `Bearer ${token}`
        }
        return config
      },
      ...
    )
  }
}

export default Request
```

 :whale: 从缓存中获取 token，并携带在头部字段。



### 状态管理

```elm
- store
  + login
    - login.ts
    - types.ts
  + index.ts
  + types.ts
```

<span style="backGround: #efe0b9">store/index.ts</span>

```javascript
import { createStore } from 'vuex'

import login from './login/login'

import { IRootState } from './types'

const store = createStore<IRootState>({
  state() {
    return {
      name: 'demo'
    }
  },
  mutations: {},
  getters: {},
  actions: {},
  modules: {
    login
  }
})

export function setupStore() {
  store.dispatch('login/loadLocalLogin')
}

export default store
```

<span style="backGround: #efe0b9">store/types.ts</span>

```javascript
export interface IRootState {
  name: string
}
```

:turtle: 对应到 state 中，在<span style="color: #da9330">使用时</span>会检测类型。



#### 登录相关逻辑

> 请求并保存 token，请求并保存用户信息，请求并保存菜单路由信息，跳转首页

<span style="backGround: #efe0b9">store/login/login.ts</span>

```javascript
import { Module } from 'vuex'

import {
  accountLoginRequest,
  requestUserInfoById,
  requestUserMenusByRoleId
} from '@/service/login/login'
import localCache from '@/utils/cache'
import router from '@/router'

import { IAccount } from '@/service/login/type'
import { ILoginState } from './types'
import { IRootState } from '../types'

const loginModule: Module<ILoginState, IRootState> = {
  namespaced: true,
  state() {
    return {
      token: '',
      userInfo: {},
      userMenus: []
    }
  },
  getters: {},
  mutations: {
    changeToken(state, token: string) {
      state.token = token
    },
    changeUserInfo(state, userInfo: any) {
      state.userInfo = userInfo
    },
    changeUserMenus(state, userMenus: any) {
      state.userMenus = userMenus
    }
  },
  actions: {
    async accountLoginAction({ commit }, payload: IAccount) {
      // 1.实现登录逻辑
      const loginResult = await accountLoginRequest(payload)
      const { id, token } = loginResult.data
      commit('changeToken', token)
      localCache.setCache('token', token)

      // 2.请求用户信息
      const userInfoResult = await requestUserInfoById(id)
      const userInfo = userInfoResult.data
      commit('changeUserInfo', userInfo)
      localCache.setCache('userInfo', userInfo)

      // 3.请求用户菜单
      const userMenusResult = await requestUserMenusByRoleId(userInfo.role.id)
      const userMenus = userMenusResult.data
      commit('changeUserMenus', userMenus)
      localCache.setCache('userMenus', userMenus)

      // 4.跳到首页
      router.push('/main')
    },
    // 用于刷新时，重新读取状态
    loadLocalLogin({ commit }) {
      const token = localCache.getCache('token')
      if (token) {
        commit('changeToken', token)
      }
      const userInfo = localCache.getCache('userInfo')
      if (userInfo) {
        commit('changeUserInfo', userInfo)
      }
      const userMenus = localCache.getCache('userMenus')
      if (userMenus) {
        commit('changeUserMenus', userMenus)
      }
    }
  }
}

export default loginModule
```

<span style="backGround: #efe0b9">store/login/types.ts</span>

```javascript
export interface ILoginState {
  token: string
  userInfo: any
  userMenus: any
}
```

由于数据结构复杂，所以使用 any



#### 刷新时读取状态

src/main.ts

```
import { setupStore } from './store'

setupStore()
```

:trident: 在每次刷新页面时执行。



### 账号登录实现

```vue
<template>
  <div class="login-panel">
    <h1 class="title">后台管理系统</h1>
    <el-tabs v-model="currentTab" stretch>
      <el-tab-pane name="account">
        <template #label>
          <span><i class="el-icon-user-solid"></i> 账号登录</span>
        </template>
        <login-account ref="accountRef" />
      </el-tab-pane>
      <el-tab-pane name="phone">...</el-tab-pane>
    </el-tabs>

    <div class="account-control">
      <el-checkbox v-model="isKeepPassword">记住密码</el-checkbox>
      <el-link type="primary">忘记密码</el-link>
    </div>

    <el-button type="primary" class="login-btn" @click="handleLoginClick"
      >立即登录</el-button
    >
  </div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'
import LoginAccount from './login-account.vue'

export default defineComponent({
  components: {
    LoginPhone,
    LoginAccount
  },
  setup() {
    // 定义属性
    const currentTab = ref('account')
    const isKeepPassword = ref(true)
    const accountRef = ref<InstanceType<typeof LoginAccount>>()

    // 定义方法
    const handleLoginClick = () => {
      if (currentTab.value === 'account') {
        accountRef.value?.loginAction(isKeepPassword.value)
      } else {
        console.log('点击手机登录')
      }
    }

    return {
      currentTab,
      isKeepPassword,
      accountRef,
      handleLoginClick
    }
  }
})
</script>
```

:turtle: 引用子组件时，类型依旧通过 `<InstanceType<typeof Component>>` 的方式获取。



```vue
<script lang="ts">
import { defineComponent, reactive, ref } from 'vue'
import { ElForm } from 'element-plus'
import { useStore } from 'vuex'
import localCache from '@/utils/cache'

import { rules } from '../config/account-config'

export default defineComponent({
  setup() {
    const store = useStore()
    const account = reactive({
      name: localCache.getCache('name') ?? '',
      password: localCache.getCache('password') ?? ''
    })
    const formRef = ref<InstanceType<typeof ElForm>>()

    const loginAction = (isKeepPassword: boolean) => {
      formRef.value?.validate((valid) => {
        if (valid) {
          // 1.判断是否需要记住密码
          if (isKeepPassword) {
            // 本地缓存
            localCache.setCache('name', account.name)
            localCache.setCache('password', account.password)
          } else {
            localCache.deleteCache('name')
            localCache.deleteCache('password')
          }

          // 2.开始进行登录验证
          store.dispatch('login/accountLoginAction', { ...account })
        }
      })
    }
    return {
      account,
      rules,
      formRef,
      loginAction
    }
  }
})
</script>
```

:cactus: <span style="color: #ff0000">记住密码</span>的逻辑其实可以一并放在 vuex 中实现。



# --首页框架--

### 基本骨架

<span style="backGround: #efe0b9">views/main/main.vue</span>

```vue
<template>
  <div class="main">
    <el-container class="main-content">
      <el-aside width="200px">Aside</el-aside>
      <el-container class="page">
        <el-header class="page-header">Header</el-header>
        <el-main class="page-main">Main</el-main>
      </el-container>
    </el-container>
  </div>
</template>
```

**结构**

```elm
- src
  + components
    - nav-menu           // 组件文件夹
      + src
        - nav-menu.vue   // 组件
      + index.ts         // 出口
    - nav-header
```

:hammer_and_wrench: 由于大部分页面都公用侧边栏和顶部栏，将它抽离到公共组件，主体部分通过动态路由控制。



### 侧边栏骨架

<span style="backGround: #efe0b9">components/nav-menu/index.ts</span>

```javascript
import NavMenu from './src/nav-menu.vue'

export default NavMenu
```



<span style="backGround: #efe0b9">components/nav-menu/src/nav-menu.vue</span>

```vue
<template>
  <div class="nav-menu">
    <div class="menu-logo">
      <img src="~@/assets/img/logo.svg" alt="" />
      <span>管理系统</span>
    </div>
    <el-menu>...</el-menu>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed } from 'vue'
import { useStore } from 'vuex'

export default defineComponent({
  setup() {
    const store = useStore()
    const userMenus = computed(() => store.state.login.userMenus)

    return {
      userMenus
    }
  }
})
</script>
```

:european_castle: 模板中使用路径别名时，用 ~ 作为开头。



### ui导航菜单组件

<span style="color: #f7534f;font-weight:600">el-menu</span> 最外部容器

<span style="color: #f7534f;font-weight:600">el-menu-item</span> 允许的选中项

<span style="color: #f7534f;font-weight:600">el-sub-menu</span>  次级容器，允许嵌套其它内容

<span style="color: #f7534f;font-weight:600">el-menu-item-group</span> 分组，拥有分组标题，嵌套相应内容作为一组



<span style="backGround: #efe0b9">components/nav-menu/src/nav-menu.vue</span>

```vue
<el-menu
  class="el-menu"
  unique-opened
  :default-active="1"
  background-color="#313131"
  text-color="#fff"
  active-text-color="#ffd04b"
>
  <template v-for="subMenu in userMenus" :key="subMenu.id">
    <el-sub-menu :index="subMenu.id">
      <template #title>{{ subMenu.name }}</template>
      <template v-for="item in subMenu.children" :key="item.id">
        <el-menu-item :index="item.id">{{ item.name }}</el-menu-item>
      </template>
    </el-sub-menu>
  </template>
</el-menu>
```

:star2: 在 vue3 中，允许并推荐在 template 中使用 <span style="color: #a50">key</span>。

:turtle: 实际上在插槽中还可以添加图标，适当增加与文字的距离以更好实现<span style="color: #a50">折叠效果</span>。



### 导航菜单的折叠

> 在顶部栏中控制导航菜单的折叠。

**发射事件**

<span style="backGround: #efe0b9">components/nav-header/src/nav-header.vue</span>

```vue
<template>
  <div class="nav-header">
    <el-icon class="expand-icon" @click="handleFoldClick">
      <fold v-if="isFold" />
      <expand v-else />
    </el-icon>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'

export default defineComponent({
  emits: ['foldChange'],
  setup(props, { emit }) {
    const isFold = ref(true)

    const handleFoldClick = () => {
      isFold.value = !isFold.value
      emit('foldChange', isFold.value)
    }
    return {
      handleFoldClick,
      isFold
    }
  }
})
</script>
```

:ghost: 通过 <span style="color: #a50">ref</span> 处理的结果是一个对象，后续改变的是它的属性，故可以使用 <span style="color: #a50">const</span> 声明。



**传递自定义属性**

<span style="backGround: #efe0b9">views/main/main.vue</span>

```react
<div class="main">
  <el-container class="main-content">
    <el-aside :width="isCollapse ? '60px' : '210px'">
      <nav-menu :collapse="isCollapse" />
    </el-aside>
    <el-container class="page">
      <el-header class="page-header">
        <nav-header @foldChange="handleFoldChange" />
      </el-header>
      <el-main class="page-main">Main</el-main>
    </el-container>
  </el-container>
</div>

setup() {
  const isCollapse = ref(false)

  const handleFoldChange = (isFold: boolean) => {
    isCollapse.value = isFold
  }
  return {
    isCollapse,
    handleFoldChange
  }
}
```

:turtle: 对于 menu 的容器，即侧边栏部分，也要动态控制其宽度以实现正常的视觉效果。

:hammer_and_wrench: 检测：定义方法的参数需要提供类型。



<span style="backGround: #efe0b9">components/nav-menu/src/nav-menu.vue</span>

```less
<el-menu :collapse="collapse"></el-menu>

.el-menu {
  border-right: none;
}
```

:whale: 导航组件默认带右边界，带来不良视觉效果。



### vuex 添加类型检测

#### 原有方式

<span style="backGround: #efe0b9">components/nav-menu/src/nav-menu.vue</span>

```react
import { useStore } from 'vuex'
setup() {
  const store = useStore()
  const userMenus = computed(() => store.state.login.userMenus)

  return {
    userMenus
  }
}
```

:octopus: 默认导入的 store，无法进行类型检测，容易出错。



#### 添加能力

<span style="backGround: #efe0b9">store/type.ts</span>

```javascript
import { ILoginState } from './login/types'

export interface IRootState {
  name: string
  age: number
}

export interface IRootWithModule {
  login: ILoginState
}

export type IStoreType = IRootState & IRootWithModule
```

:hammer_and_wrench: 增加了模块时，继续交叉相应的类型再导出即可。



<span style="backGround: #efe0b9">store/index.ts</span>

```javascript
import { Store, useStore as useVuexStore } from 'vuex'
import { IStoreType } from './types'

export function useStore(): Store<IStoreType> {
  return useVuexStore()
}
```

:european_castle: 导入时使用别名的方法防止命名冲突；

:ghost: 给原本的方法增加了返回值的类型。



<span style="backGround: #efe0b9">components/nav-menu/src/nav-menu.vue</span>

```react
import { useStore } from '@/store'

setup() {
  const store = useStore()
  const userMenus = computed(() => store.state.login.userMenus)
  return {
    userMenus
  }
}
```

:trident: 使用时唯一的区别在于导入位置的不同。

