### 更改默认服务器

在 `config.js` 中修改，默认使用本地的服务器，将被拼接到 `basicRequest` 中作为接口地址的一部分。

原地址

```javascript
const ServicesBasePath = 'http://localhost:8080';
// 注意：无工程名时为空字符串
const ContextPath = 'job_service_platform';
```

锦烁

```javascript
const ServicesBasePath = 'http://192.168.0.206:8080';
const ContextPath = 'job';
```

浩松

```javascript
const ServicesBasePath = 'http://192.168.0.214:8080';
const ContextPath = 'job_service_platform';
```



### 代理开发服务器

> 在 `webpack.config.js` 中设置，作为开发服务器的地址。

`devServer.host` 主机名

`devServer.port` 端口

`devServer.proxy.***.target` 代理的某个环境的域名

## 通用

### 登录超时

`basicRequest.js`。 

1. 如果常规请求（请求回调）返回特定状态码，意味着登录失效。
2. 会根据缓存中的环境，跳转到对应的登录页面



### 确认密码&提交表单

> 两次输入的密码需一致，需要将自定义验证规则项写成箭头函数获取 `this`，并在修改密码项后再次验证确认密码。

```vue
<el-form :model="form" :rules="rules" ref="form" label-width="100px">
  <el-form-item label="密码" prop="pass">
    <el-input v-model="form.pass"></el-input>
  </el-form-item>
  <el-form-item label="确认密码" prop="checkPass">
    <el-input v-model="form.checkPass"></el-input>
  </el-form-item>
  <el-form-item>
    <el-button @click="submitForm('form')">提交</el-button>
  </el-form-item>
</el-form>
```

```javascript
data() {
  return {
    form: {
      pass: "",
      checkPass: "",
    },
    rules: {
      pass: [
        {
          validator: (rule, value, callback) => {
            if (value === "") {
              callback(new Error("请输入密码"));
            } else {
              if (this.form.checkPass !== "") {
                this.$refs.form.validateField("checkPass");
              }
              callback();
            }
          },
          trigger: "blur",
        },
      ],
      checkPass: [
        {
          validator: (rule, value, callback) => {
            if (value === "") {
              callback(new Error("请再次输入密码"));
            } else if (value !== this.form.pass) {
              callback(new Error("两次输入密码不一致!"));
            } else {
              callback();
            }
          },
          trigger: "blur",
        },
      ],
    },
  }
},
methods: {
  submitForm(formName) {
    this.$refs[formName].validate((valid) => {
      if (!valid) {
        return false;
      } else {
        alert("验证通过，手动调用接口");
      }
    });
  }
},
```



### 修改的信息渲染到其它组件

> 由于信息中的头像和名字部分还会渲染到顶部栏组件中，故需在成功的回调中更新顶部栏的数据。

  A. 发送自定义事件，在父组件通过 `$refs` 调用顶部栏组件的初始化（请求）数据的方法。

  B. 一开始就通过 VueX 保存数据，并在不同组件中引用。

  C. 使用事件总线。



### 弹窗修改表单项

> 如编辑信息页面，修改手机号时为弹窗形式。成功时，重新初始化当前页面数据。



### 导航栏激活类的完善

> 当回退、刷新页面、进入非导航栏相关页时，也能正确将激活类添加到相应元素上。

```javascript
/* 当前页面路由（查询参数）改变时触发 */
watch: {
  '$route': 'initActiveItem'
},
methods: {
  // 初始化导航栏的激活项
  initActiveItem() {
    let routeItem = ["home", "position-manager", "search", "resume-manager"];
    let result = routeItem.some((item) => {
    if (this.$route.path.indexOf(item) !== -1) {
      this.choice = item;
      return true;
    }
      return false;
    });
    // 如果不是其中的任一一个路由
    if (!result) {
      this.choice = "";
    }
  }
},
created() {
  /* 刷新页面时触发 */
  this.initActiveItem();
}
```



### 展开/收起渲染不同内容

> 可以通过 `v-if` 和 `v-else` 实现整块内容的替换。 只有少量不同时，对相关的部分条件渲染即可。



## 规范

### 登录后的权限管理

1. 在页面的 `created ` 阶段，获取是否登录的信息，保存到实例中。
2. 执行相关逻辑时，判断是否登录。
3. 这样做在一定程度上较为规范吧。



### 公用搜索框组件的处理

  ① 搜索框发射自定义事件，参数为输入框绑定值

  ① home组件和search组件中都有搜索框这个子组件，接收到事件后，会执行不同逻辑

  ② home组件会（发射事件再用$refs调用顶部导航栏的方法）让顶部导航栏的激活项改变、然后携带查询参数跳转到search页面

  ② 此时search组件会将该值保存到本地（作为搜索框的查询值），然后发起请求，并在 `mounted` 时调用搜索框组件的方法，更新其绑定值（因为是不同的搜索框组件）

  ③ search组件会将查询参数保存到本地，然后发起请求



### uniAppToken相关逻辑

> 常规请求指使用了 `this.$basicRequest.request` 发起的正常业务请求。 常规请求被分为了请求前、发起请求和请求回调，在请求前进行了配置合并、拼接路径等处理。

1. `this.$basicRequest.request` 首先会判断本地有无 `uniAppToken` 值，如果有，执行常规请求。
2. 如果没有，（不管该常规请求是否需要）先请求 `uniAppToken`，成功后执行常规请求。
3. 如果 `请求回调` 返回特定状态码，意味着 `uniAppToken` 过期。
4. 自动请求 `uniAppToken`，保存到缓存，然后再次执行常规请求。
5. `请求前` 会判断缓存有无 `uniAppToken` 及 `appendUniAppToken` 是否为 true，有则拼接到路径后。
6. `appendUniAppToken` 默认为true，可以由外部传入，表示路径需要拼接 `uniAppToken`。



### 请求图片的预处理

> 图片路径需要加上服务器地址（和工程名）；这里没用箭头函数，只能将 `this` 通过变量传入。

```javascript
import baseConfig from "../../../config.js";

success: function(data, parameters) {
  let data = data.data;
  me.relativeIamge = me.$baseConfig.getServicePath() + data.relativeIamge;
}
```



### 正则替换v-html图片路径

> 请求到的 html 中的图片路径为相对（服务器）的路径，在前端需要将其替换为绝对路径，也就是将其拼接到服务器路径后。 `ContextPath` 为工程名，存在时还要让其紧跟到服务器路径后。

```javascript
success: function(data, parameters) {
  // 处理后保存到本地
  let contentHtml = me.$pageHelper.modifyContentImgSrc(data.content);
  me.info.content = contentHtml;
}
```

```javascript
const modifyContentImgSrc = function(html) {
  if (!html) {
    return "";
  }
  let me = this;
  // 使用正则表达式进行替换
  html = html.replace(/<img [^>]*src=['"]([^'"]+)[^>]*>/gi, function(match) {
    let contextPath = baseConfig.ContextPath == "" ? baseConfig.ContextPath : "/" + baseConfig.ContextPath;
    return match.replace(contextPath + "/attached/image", baseConfig.getServicePath() + "/attached/image");
  });
  return html;
};
```

> 字符串的 `replace` 方法会找到调用者中的首参部分（正则捕获的内容），将其替换为第二个参数。
>
> 若第二个参数为方法，[该方法](https://www.cnblogs.com/smile-fanyin/p/13035710.html)接受的第一个参数为正则捕获的内容。

`config.js`

```javascript
const ServicesBasePath = 'http://192.168.0.217:8080';
// 工程名
const ContextPath = 'job_service_platform';

const getServicePath = function(){
	var baseServicesBasePath = this.ServicesBasePath;
	baseServicesBasePath = baseServicesBasePath + "/";
	// 替换字符串最后字符,将双斜杠转换为单斜杠
	baseServicesBasePath = baseServicesBasePath.replace(/\/{2}$/g,"/");
	// 如果存在工程名，则在后面拼接上工程名
	if(this.ContextPath&&this.ContextPath!=""){
		return baseServicesBasePath+this.ContextPath + "/";
	}
	return baseServicesBasePath;
};
```

#### 



## debbger

### 三级关联下拉框

> 下拉框存在数据依赖的父子关系。在第三级下拉框点击时值不能赋上去，此后更改其他下拉框值又能重新出现，推测在响应式出现了问题。

```javascript
LargeSelectChange() {
    // 原写法，无法触发响应式
    this.form.smallJob = '';
    // 需更改为Vue能检测到的方法，栗子：
    this.$set(this.form, 'smallJob', '');
},
```



### 动态类无法加上  

> 尽管动态类的表达式值为 `true`，但类名无法正常添加到元素上。
>
> 因为表达式为对象的属性，推测与响应式有关，替换其表达式后发现果然如此。
>
> 用 `obj={...obj}` 方法测出了出现问题的地方。

```javascript
// 初始化时就要用能响应的方法
me.$set(me.pageData.bookList[j],"checked", false);
// 更改值时用任一方法均可
me.$set(me.pageData.bookList[j],"checked", false);
me.pageData.bookList[j]['checked'] = true;
```

 



