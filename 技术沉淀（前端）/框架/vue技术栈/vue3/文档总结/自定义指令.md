# 自定义指令



### 使用手册

| 参数       | 类型       | 说明                                                         | 可选 |
| ---------- | ---------- | ------------------------------------------------------------ | ---- |
| name       | str        | 填写 definition 时，定义实例；忽略 definition 时，返回指令定义 | 必填 |
| definition | func / obj | 类型为 func 时，为函数指令（在 mounted 和 updated 调用）     | 可选 |

```javascript
import { createApp } from 'vue'
const app = createApp({})

// 注册
app.directive('my-directive', {
  // 指令具有一组生命周期钩子：
  // 在绑定元素的 attribute 或事件监听器被应用之前调用
  created() {},
  // 在绑定元素的父组件挂载之前调用
  beforeMount() {},
  // 在绑定元素的父组件挂载之后调用
  mounted() {},
  // 在包含组件的 VNode 更新之前调用
  beforeUpdate() {},
  // 在包含组件的 VNode 及其子组件的 VNode 更新之后调用
  updated() {},
  // 在绑定元素的父组件卸载之前调用
  beforeUnmount() {},
  // 在绑定元素的父组件卸载之后调用
  unmounted() {}
})

// 注册 (函数指令)
app.directive('my-directive', () => {
  // 这将被作为 `mounted` 和 `updated` 调用
})

// getter, 如果已注册，则返回指令定义
const myDirective = app.directive('my-directive')
```

#### 指令钩子参数

| 参数     | 说明                                                | 注意 |
| -------- | --------------------------------------------------- | ---- |
| el       | 绑定的元素，用于直接操作 DOM                        |      |
| binding  | 包含组件实例、传值、参数、修饰符等信息              | 只读 |
| vnode    | 虚拟节点，对应el                                    | 只读 |
| prevNode | 上一个虚拟节点，仅出现在 `beforeUpdate` / `updated` | 只读 |

#### binding参数解析

| 参数      | 说明                                              | 示例                                                   |
| --------- | ------------------------------------------------- | ------------------------------------------------------ |
| instance  | 使用指令的组件实例                                |                                                        |
| value     | 传递给指令的值                                    | `v-my-directive="1 + 1"` 对应 2                        |
| oldValue  | 先前的值，仅在 `beforeUpdate` 和 `updated` 中可用 | 只读                                                   |
| arg       | 传递给指令的参数                                  | `v-my-directive:foo` 对应 foo                          |
| modifiers | 包含修饰符的对象                                  | `v-my-directive.foo.bar` 对应 `{foo: true，bar: true}` |
| dir       | 在注册指令时作为参数传递                          |                                                        |



#### 传入多个值

如果指令需要多个值，可以传入对象

```vue
<div v-demo="{ color: 'white', text: 'hello!' }"></div>
```

```javascript
app.directive('demo', (el, binding) => {
  console.log(binding.value.color) // => "white"
  console.log(binding.value.text) // => "hello!"
})
```



#### 在元素/组件使用

当在组件中使用时，自定义指令总是会被应用在组件的根节点上。



### 例子-自动聚焦

```javascript
const app = Vue.createApp({})

// `v-focus`：当被绑定的元素挂载到 DOM 中时，聚焦元素
app.directive('focus', {
  mounted(el) {
    el.focus()
  }
})
```

```vue
<input v-focus />
```



### 例子-固定布局

> 控制通过固定布局将元素固定在页面上，可以传入参数和值来控制其固定的位置。

**定义**

```javascript
app.directive('pin', {
  mounted(el, binding) {
    el.style.position = 'fixed'
    // binding.arg 是我们传递给指令的参数
    const s = binding.arg || 'top'
    el.style[s] = binding.value + 'px'
  }
})
```

**使用**

```vue
<!-- 模板 -->
<p v-pin:right="200">I am pinned onto the page at 200px to the left.</p>
```

或使用[动态参数](https://v3.cn.vuejs.org/guide/template-syntax.html#动态参数)

```vue
<!-- 模板 -->
<p v-pin:[direction]="200">I am pinned onto the page at 200px to the left.</p>

<script setup lang="ts">
  const direction = "right";
</script>
```



### 例子-固定布局-增强

传给指令的值可以是动态的，以实现更好的交互

**定义**

```javascript
app.directive('pin', {
  mounted(el, binding) {
    el.style.position = 'fixed'
    const s = binding.arg || 'top'
    el.style[s] = binding.value + 'px'
  },
  updated(el, binding) {
    const s = binding.arg || 'top'
    el.style[s] = binding.value + 'px'
  }
})
```

:whale: 这里完全可以写成函数指令的形式

**使用**

```vue
<!-- 模板 -->
<p v-pin:[direction]="pinPadding">I am pinned onto the page at 200px to the left.</p>
<input type="range" min="0" max="500" v-model="pinPadding" />

<script setup lang="ts">
import { ref, onBeforeMount } from "vue";

const direction = "right";
const pinPadding = ref(100);

</script>
```



### 例子-复制到剪切板

这里给元素添加一个属性，用于记录最新的需要粘贴的值

```javascript
app.directive('copy', {
  mounted(el, { value }) {
    el.$value = value;
    el.handler = () => {
      if (!el.$value) {
        console.log('复制内容为空');
        return;
      }
      const aux = document.createElement('input');
      aux.setAttribute('value', el.$value);
      document.body.appendChild(aux);
      aux.select();
      document.execCommand('copy');
      document.body.removeChild(aux);
      console.log('复制成功');
    };
    el.addEventListener('click', el.handler);
  },
  updated(el, { value }) {
    el.$value = value;
  },
  unmounted(el) {
    el.removeEventListener('click', el.handler);
  },
})
```

```vue
<p v-copy="text">{{ text }}</p>
```

这里的打印可以替换为 UI 组件的弹出框，效果更好。



### 对比vue2

钩子的命名和定义不一样了

```javascript
App.directive('copy', {
  bind(el, { value }) {
    el.$value = value;
    el.handler = () => {
      if (!el.$value) {
        message.error('复制内容为空');
        return;
      }
      const aux = document.createElement('input');
      aux.setAttribute('value', el.$value);
      document.body.appendChild(aux);
      aux.select();
      document.execCommand('copy');
      document.body.removeChild(aux);
      message.success('复制成功');
    };
    el.addEventListener('click', el.handler);
  },
  update(el, { value }) {
    el.$value = value;
  },
  componentUpdated(el, { value }) {
    el.$value = value;
  },
  unbind(el) {
    el.removeEventListener('click', el.handler);
  },
})
```



### 封装思路

```elm
- directives
  + copy     // 各指令入口
    index.js
  + index.js // 出口
```

<span style="backGround: #efe0b9">directives/index.js</span>

```javascript
import copy from './copy';

const directives = {
  copy, // 同时命名
};

export default {
  install(app) {
    Object.keys(directives).forEach((key) => {
      app.directive(key, directives[key]);
    });
  },
};
```

<span style="backGround: #efe0b9">directives/copy/index.js</span>

```javascript
/* 对应 app.directive 的第二个参数 */
const Copy = {/* code */};

export default Copy;
```

<span style="backGround: #efe0b9">main.ts</span>

```javascript
import directives from './directives';

app.use(directives);
```





# 插槽

| 知识点                 | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 插槽内容               | 子组件中存在 `<slot>` 时，该组件起始标签和结束标签之间的任何内容（文本、元素或组件）会把其替换掉 `<slot>` |
| 插槽内容               | 子组件中存在 `<slot>` 时，该内容会被抛弃                     |
| 渲染作用域             | 父级模板里的所有内容都是在父级作用域中编译的；不能使用子模板内的数据 |
| 备用内容               | 父级组件没有提供内容时，将用 `<slot>` 中的内容替换掉 `<slot>` |
| 具名插槽               | 当需要提供多个插槽时，可以通过 `name` 分配不同的 ID          |
| 具名插槽               | 不带 `name` 的 `<slot>` 会带有隐含的名字 default             |
| 作用域插槽             | 让插槽内容能够访问子组件中才有的数据                         |
| 作用域插槽             | 提供：在 `<slot>` 上添加属性，可提供多个（这些属性被称为插槽 Prop） |
| 作用域插槽             | 消费：传递到 v-slot 的值上，该值本身是一个对象（任意命名），提供的数据将作为对象属性 |
| 独占默认插槽的缩写语法 | 只提供默认插槽的内容时，可以不使用 template，而是直接把 v-slot 添加到组件上 |
| 解构插槽 Prop          | 消费作用域插槽的值时，可以通过解构只取需要的值，届时还可以重命名、提供默认值 |
| 动态插槽名             | 使用[动态指令参数](https://v3.cn.vuejs.org/guide/template-syntax.html#动态参数)，可以动态的使用插槽名 |
| 具名插槽的缩写         | 可以将` v-slot:` 替换为`#`                                   |
| 具名插槽的缩写         | 默认插槽使用缩写时，不能省略参数，即需要为 `#default`        |



#### 具名插槽

```vue
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

定义具名插槽，添加 name 属性

```vue
<template v-slot:header>
  <h1>Here might be a page title</h1>
</template>

<template v-slot:default>
  <p>A paragraph for the main content.</p>
  <p>And another one.</p>
</template>

<template v-slot:footer>
  <p>Here's some contact info</p>
</template>
```

为具名插槽提供内容，在 template 标签上通过 v-slot 指明是哪个



#### 作用域插槽

子组件

```vue
<ul>
  <li v-for="( item, index ) in items">
    <slot :item="item"></slot>
  </li>
</ul>
```

父组件

```vue
<todo-list>
  <template v-slot:default="slotProps">
    <i class="fas fa-check"></i>
    <span class="green">{{ slotProps.item }}</span>
  </template>
</todo-list>
```



#### 独占默认插槽的缩写语法

```vue
<todo-list v-slot="slotProps">
  <i class="fas fa-check"></i>
  <span class="green">{{ slotProps.item }}</span>
</todo-list>
```



#### 动态插槽名

```vue
<base-layout>
  <template v-slot:[dynamicSlotName]>
    ...
  </template>
</base-layout>
```





# 动画/过渡

### 概述

组件进入和离开 DOM 的钩子，在 CSS 和 JS 中均可用，使用内置的 `<transition>` 组件

| --                      | --                                       |
| ----------------------- | ---------------------------------------- |
| 基于 class 的动画和过渡 | 可以通过动态添加 class 来激活动画        |
| 过渡与 Style 绑定       | 可以通过插值实现过渡效果，见例子         |
| transform / opacity     | 更改其不会触发任何几何形状变化或绘制     |
| 硬件加速                | 某些属性让浏览器知道需要硬件加速，见例子 |
| 时长                    | 很多情况下，*0.25s* 是最佳选择           |



 过渡与 Style 绑定

```javascript
<div class="movearea" :style="{ backgroundColor: `hsl(${x}, 80%, 50%)` }">

.movearea {
  transition: 0.2s background-color ease;
}
```



硬件加速

如果要对一个元素进行硬件加速，可以应用以下任何一个 property (并不是需要全部，任意一个就可以)：

```
perspective: 1000px;
backface-visibility: hidden;
transform: translateZ(0);
```



### 进入/离开过渡

| --                    | --                                       |
| --------------------- | ---------------------------------------- |
| 添加进入/离开过渡时机 | 条件渲染、条件展示、动态组件、组件根节点 |



#### 简单例子

```vue
<template>
  <!-- 动画 -->
  <div id="demo">
    <button @click="show = !show">Toggle</button>

    <transition name="fade">
      <p v-if="show">hello</p>
    </transition>
  </div>
</template>

<script setup lang="ts">
import { ref } from "vue";

const show = ref(true);
</script>

<style>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.5s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```



当插入或删除包含在 `transition` 组件中的元素时

| 可能执行 | 条件                                  | 操作                                    |
| -------- | ------------------------------------- | --------------------------------------- |
| ①        | 嗅探目标元素是否应用了 CSS 过渡或动画 | 在恰当的时机添加/删除 CSS 类名          |
| ②        | 过渡组件提供了钩子函数                | 在恰当的时机调用钩子函数                |
| ③        | 前两个条件都不满足                    | DOM 操作 (插入/删除) 在下一帧中立即执行 |





#### 过渡class

| --             | 生效时机               | 移除时机               | --                                               |
| -------------- | ---------------------- | ---------------------- | ------------------------------------------------ |
| v-enter-from   | 元素被插入前           | 元素被插入之后的下一帧 |                                                  |
| v-enter-active | 元素被插入前           | 过渡/动画完成之后      | 可以被用来定义进入过渡的过程时间，延迟和曲线函数 |
| v-enter-to     | 元素被插入之后的下一帧 | 过渡/动画完成之后      |                                                  |
| v-leave-from   | 离开过渡被触发时       | 下一帧                 |                                                  |
| v-leave-active | 离开过渡被触发时       | 过渡/动画完成之后      | 可以被用来定义离开过渡的过程时间，延迟和曲线函数 |
| v-leave-to     | 离开过渡被触发后下一帧 | 过渡/动画完成之后      |                                                  |

![image-20220711114500716](D:/娱乐休闲/Wechat/Wechat文件管理/WeChat Files/wxid_sa4inldgv2gj22/FileStorage/File/2022-08/img2/动画.png)



类名会根据 `<transition>` 的 name 属性添加前缀，如果忽略该属性，前缀就是 `v-`



#### CSS 过渡

```vue
<template>
  <div id="demo">
    <button @click="show = !show">Toggle</button>

    <transition name="slide-fade">
      <p v-if="show">hello</p>
    </transition>
  </div>
</template>

<script setup lang="ts">
import { ref } from "vue";

const show = ref(true);
</script>

<style>
/* 可以为进入和离开动画设置不同的持续时间和动画函数 */
.slide-fade-enter-active {
  transition: all 0.3s ease-out;
}

.slide-fade-leave-active {
  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
}

.slide-fade-enter-from,
.slide-fade-leave-to {
  transform: translateX(20px);
  opacity: 0;
}
</style>
```



#### CSS 动画

用法同 CSS 过渡，区别是在动画中 `v-enter-from` 类在节点插入 DOM 后不会立即移除，而是在 `animationend` 事件触发时移除。

```vue
<template>
  <!-- 动画 -->
  <div id="demo">
    <button @click="show = !show">Toggle show</button>
    <transition name="bounce">
      <p v-if="show">
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris
        facilisis enim libero, at lacinia diam fermentum id. Pellentesque
        habitant morbi tristique senectus et netus.
      </p>
    </transition>
  </div>
</template>

<script setup lang="ts">
import { ref } from "vue";

const show = ref(true);
</script>

<style>
.bounce-enter-active {
  animation: bounce-in 0.5s;
}
.bounce-leave-active {
  animation: bounce-in 0.5s reverse;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.25);
  }
  100% {
    transform: scale(1);
  }
}
</style>
```



#### 钩子

以下将 `transition` 标签简称为动画标签，所指的属性都是添加到它上面。

| --                    | --                                                           |
| --------------------- | ------------------------------------------------------------ |
| 类名前缀              | 类名会根据动画标签的 name 属性添加前缀，如果忽略该属性，前缀就是 `v-` |
| 自定义过渡 class 类名 | 可以通过设置 [enter-from-class](https://v3.cn.vuejs.org/guide/transitions-enterleave.html#自定义过渡-class-类名) 等属性来自定义过渡类名，在与第三方 CSS 动画库结合使用时有用 |
| 同时使用过渡和动画    | 这种情况下，要设置 [type](https://v3.cn.vuejs.org/guide/transitions-enterleave.html#同时使用过渡和动画) 属性，显式声明需要 Vue 监听的类型 |
| 显性的过渡持续时间    | 比如嵌套的内部元素有更长的延迟/过渡，这时可以设置 [duration](https://v3.cn.vuejs.org/guide/transitions-enterleave.html#显性的过渡持续时间) 属性，显式指定过渡持续时间 |
| 初始渲染时添加过渡    | 设置 [appear](https://v3.cn.vuejs.org/guide/transitions-enterleave.html#初始渲染的过渡) 属性 |
| 多元素之间的过渡      | 可以设置 [mode](https://v3.cn.vuejs.org/guide/transitions-enterleave.html#过渡模式) 属性来添加过渡模式，大多情况选择 out-in |
| 钩子                  | transition 支持 class / 钩子两种方式，配合某些库使用时，钩子会更好 |
| 钩子                  | 可以设置 [@before-enter](https://v3.cn.vuejs.org/guide/transitions-enterleave.html#javascript-钩子) 等钩子 |
| 钩子                  | 单独使用钩子时，enter 和 leave 钩子必须使用 done 进行回调，否则过渡立即完成 |
| 钩子                  | 可以设置 `:css="false"` 跳过css检测，性能略高，且避免过渡过程受到css影响 |



#### 多个元素之间的过渡

```vue
<button @click="show = !show">切换</button>
<transition name="bounce">
  <p v-if="show">Lorem</p>
  <p v-else>ipsum</p>
</transition>
```

对于元素间的过渡，因为考虑到内部的更新机制，可以给切换的元素提供 key。



##### 添加过渡模式

默认情况下，进入和离开会同时发生，很多时候我们不想要这样的效果，需要协调进入和离开的状态，可以添加 mode 属性

```vue
<button @click="show = !show">切换</button>
<transition name="bounce" mode="out-in">
  <p v-if="show">Lorem</p>
  <p v-else>ipsum</p>
</transition>
```

- `in-out`: 新元素先进行进入过渡，完成之后当前元素过渡离开。
- `out-in`: 当前元素先进行离开过渡，完成之后新元素过渡进入。



#### 多个组件之间的过渡

可以使用动态组件，而不需要添加 key

```vue
<div id="demo">
  <input v-model="view" type="radio" value="v-a" id="a"><label for="a">A</label>
  <input v-model="view" type="radio" value="v-b" id="b"><label for="b">B</label>
  <transition name="bounce" mode="out-in">
    <component :is="view"></component>
  </transition>
</div>

data() {
  return {
    view: 'v-a'
  }
},
components: {
  'v-a': {
    template: '<div>Component A</div>'
  },
  'v-b': {
    template: '<div>Component B</div>'
  }
}
```



### 列表过渡

transition-group

| --           | --                                                           |
| ------------ | ------------------------------------------------------------ |
| 包裹元素     | 默认情况下，不会渲染包裹元素。可以设置 `tag` 属性指定包裹元素的类型 |
| 过渡模式     | 不可用，因为不再相互切换特有的元素                           |
| key          | 内部元素<span style="color: #ff0000">必须</span>提供唯一key  |
| 过渡 class   | 过渡的类将会应用在内部的元素中，而不是这个组/容器本身        |
| 可复用的过渡 | 可以通过插槽实现可复用的过渡组件，有个很好的函数式组件 [demo](https://v3.cn.vuejs.org/guide/transitions-list.html#可复用的过渡) |
| 动态过渡     | 可以通过动态切换 name，来使用不同的过渡类                    |
| 动态过渡     | 使用钩子时，使用 data 中的数据可以方便地控制位移，动画时长等属性 |

#### 例子

```vue
<template>
  <!-- 动画 -->
  <div id="list-demo">
    <button @click="add">Add</button>
    <button @click="remove">Remove</button>
    <transition-group name="list" tag="p">
      <span v-for="item in items" :key="item" class="list-item">
        {{ item }}
      </span>
    </transition-group>
  </div>
</template>
<script setup lang="ts">
import { ref } from "vue";
const items = ref([1, 2, 3, 4, 5, 6, 7, 8, 9]);
const nextNum = ref(10);

function randomIndex() {
  return Math.floor(Math.random() * items.value.length);
}
function add() {
  items.value.splice(randomIndex(), 0, nextNum.value++);
}
function remove() {
  items.value.splice(randomIndex(), 1);
}
</script>

<style>
.list-item {
  display: inline-block;
  margin-right: 10px;
}
.list-enter-active,
.list-leave-active {
  transition: all 1s ease;
}
.list-enter-from,
.list-leave-to {
  opacity: 0;
  transform: translateY(30px);
}
</style>
```

这个例子有一个问题，当添加和移除元素的时候，周围的元素会瞬间移动到它们的新布局的位置，而不是平滑的过渡。



#### 例子-优化

```vue
<template>
  <!-- 动画 -->
  <div id="list-complete-demo" class="demo">
    <button @click="shuffle">Shuffle</button>
    <button @click="add">Add</button>
    <button @click="remove">Remove</button>
    <transition-group name="list-complete" tag="p">
      <span v-for="item in items" :key="item" class="list-complete-item">
        {{ item }}
      </span>
    </transition-group>
  </div>
</template>

<script setup lang="ts">
import { ref } from "vue";

const items = ref([1, 2, 3, 4, 5, 6, 7, 8, 9]);
const nextNum = ref(10);

function randomIndex() {
  return Math.floor(Math.random() * items.value.length);
}
function add() {
  items.value.splice(randomIndex(), 0, nextNum.value++);
}
function remove() {
  items.value.splice(randomIndex(), 1);
}
function shuffle() {
  items.value = [3, 2, 1, 4, 5, 6, 7, 8, 9];
}
</script>

<style>
.list-complete-item {
  transition: all 0.8s ease;
  display: inline-block;
  margin-right: 10px;
}

.list-complete-enter-from,
.list-complete-leave-to {
  opacity: 0;
  transform: translateY(30px);
}

.list-complete-leave-active {
  position: absolute;
}
</style>
```

为定位的改变添加动画：可以通过新增的 `v-move` 类，或者直接拿到内部元素的类名定义，这里是 `list-complete-item` 或者 `list-complete-move`

这个类主要用于指定过渡时长和缓动效果曲线

需要注意的是使用 FLIP 过渡的元素不能设置为 `display: inline`。作为替代方案，可以设置为 `display: inline-block` 或者将元素放置于 flex 布局中。



### 状态过渡

| 例子         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| 数值动态变化 | 将 5 改变为 10，这个过程会显示中间数字（借助[GreenSock](https://greensock.com/)） |
| 设置SVG动画  | 可以通过设置几个属性，改变它的动画效果                       |





## 响应性基础 API

要使用这些API，需要从 vue 中导出

```javascript
import { reactive, isReactive } from 'vue'
```

| API             | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| reactive        | 深层地进行响应式转换                                         |
| reactive        | 应用于普通对象，可以返回对象的响应式副本                     |
| reactive        | 使用 ref 的属性会被代理自动解包                              |
| readonly        | 接收响应式 / 纯对象或 ref 并返回只读代理，只读代理是深层的   |
| readonly        | 自动解包 ref                                                 |
| isProxy         | 检查参数对象是否为 reactive 或 readonly 创建的代理           |
| isReactive      | 检查参数对象是否为 reactive 创建的代理                       |
| isReactive      | 如果该代理是 readonly 创建的，但包裹了由 reactive 创建的另一个代理，也会返回 true |
| isReadonly      | 检查参数对象是否为 readonly 创建的代理                       |
| toRaw           | 返回 reactive 或 readonly 代理的原始对象                     |
| markRaw         | 标记一个对象，使其永远不会转换为代理                         |
| shallowReactive | 浅层地进行响应式转换                                         |
| shallowReactive | 使用 ref 的属性<span style="color: green">不会</span>被代理自动解包 |
| shallowReadonly | 返回只读代理，只读代理是浅层的                               |
| shallowReadonly | 使用 ref 的属性<span style="color: green">不会</span>被代理自动解包 |

### reactive-添加响应

```javascript
const obj = reactive({ count: 0 })
```

### reactive-解包ref

将解包所有深层的 ref，同时维持 ref 的响应性

```javascript
const count = ref(1)
const obj = reactive({ count })

// ref 会被解包
console.log(obj.count === count.value) // true

// 它会更新 `obj.count`
count.value++
console.log(count.value) // 2
console.log(obj.count) // 2

// 它也会更新 `count` ref
obj.count++
console.log(obj.count) // 3
console.log(count.value) // 3
```

### reactive-接收ref

当将 ref 分配给 reactive 实例的属性时，ref 将被自动解包

```javascript
const count = ref(1)
const obj = reactive({})

obj.count = count

console.log(obj.count) // 1
console.log(obj.count === count.value) // true
```



##  Refs

| API        | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| ref        | 返回接收值（即内部值）的响应式代理                           |
| ref        | 本身只有一个 value 属性，为接收值                            |
| ref        | 接收对象时，会通过 reactive 处理，响应是深层的               |
| unref      | 如果参数是一个 ref，则返回内部值，否则返回参数本身           |
| toRef      | 为源响应式对象上的某个属性新创建一个 ref，且保持对其源属性的响应式连接 |
| toRef      | 在使用可选 prop 时特别有用，即使源属性不存在，也会创建 ref   |
| toRefs     | 将响应式对象转换为普通对象，但返回对象的每个属性都是指向源属性的 ref |
| toRefs     | 可以在不丢失响应性的情况下对返回的对象进行解构               |
| toRefs     | 只会为源对象中包含的属性生成 ref                             |
| isRef      | 检查值是否为一个 ref 对象                                    |
| customRef  | 创建自定义的 ref，可以显式控制其依赖项跟踪和更新触发         |
| shallowRef | 创建浅层响应的 ref                                           |
| triggerRef | 手动执行与shallowRef 关联的任何作用 (effect)                 |

### toRef-可选prop

```javascript
export default {
  setup(props) {
    useSomeFeature(toRef(props, 'foo'))
  }
}
```

当你要将 prop 的 ref 传递给复合函数时，`toRef` 很有用

可选 prop 并不会被 toRefs 处理，但是 toRef 依旧返回一个可用的 ref。

### toRefs-解构响应式对象

```javascript
function useFeatureX() {
  const state = reactive({
    foo: 1,
    bar: 2
  })

  // 操作 state 的逻辑

  // 返回时转换为ref
  return toRefs(state)
}

export default {
  setup() {
    // 可以在不失去响应性的情况下解构
    const { foo, bar } = useFeatureX()

    return {
      foo,
      bar
    }
  }
}
```



## Computed 与 watch

| API                                                      | 说明                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| computed                                                 | 接收函数（getter），根据返回值创建不可变的 ref               |
| computed                                                 | 接收对象（具有 get 和 set 函数），创建可写的 ref             |
| watchEffect                                              | 接收函数，立即执行，并在其依赖变更时重新运行该函数           |
| watchPostEffect <span style="color:#42b983;">3.2+</span> | 即 watchEffect，且 `flush: 'post'`                           |
| watchSyncEffect <span style="color:#42b983;">3.2+</span> | 即 watchEffect，且 `flush: 'sync'`                           |
| watch                                                    | 默认不会立即执行，仅在侦听源发生变化时被调用                 |
| watch                                                    | 对比 watchEffect，可以侦听状态的先前值和当前值               |
| watch                                                    | 侦听器数据源可以是具有返回值的 getter 函数，或 ref           |
| watch                                                    | 侦听器还可以使用数组以同时侦听多个源                         |
| watch                                                    | 与 watchEffect，在手动停止侦听、清除副作用、刷新时机和调试方面行为相同 |

### computed-只读

```javascript
const count = ref(1)
const plusOne = computed(() => count.value + 1)

console.log(plusOne.value) // 2

plusOne.value++ // 错误
```

### computed-读写

```javascript
const count = ref(1)
const plusOne = computed({
  get: () => count.value + 1,
  set: val => {
    count.value = val - 1
  }
})

plusOne.value = 1
console.log(count.value) // 0
```

### watch-侦听单一源

```javascript
// 侦听一个 getter
const state = reactive({ count: 0 })
watch(
  () => state.count,
  (count, prevCount) => {
    /* ... */
  }
)

// 直接侦听一个 ref
const count = ref(0)
watch(count, (count, prevCount) => {
  /* ... */
})
```

### watchEffect-停止侦听

```javascript
const stop = watchEffect(() => {
  /* ... */
})

// later
stop()
```

可以显式调用返回值以停止侦听

在组件的 setup 选项或生命周期钩子中调用时，能够在组件卸载时自动停止

### watchEffect-清除副作用

对于一些异步的逻辑，在其返回结果前，我们可能希望它们被清除。watchEffect 本身传入一个参数，该参数方法接收一个函数

```javascript
watchEffect(onInvalidate => {
  const token = performAsyncOperation(id.value)
  onInvalidate(() => {
    token.cancel()
  })
})
```

函数将会在副作用即将重新执行时/组件卸载时调用。



场景：对于可能发生的连续请求，只需要最新的结果

```javascript
const data = ref(null)
watchEffect(async onInvalidate => {
  // 在Promise解析之前注册清除函数
  onInvalidate(() => {
    /* ... */
  })
  data.value = await fetchData(props.id)
})
```



### watchEffect-副作用刷新时机

副作用函数会被缓存，并异步调用，来避免同个 “tick” 中由于多个状态改变导致的重复调用。

默认情况下，会在组件 `update` **前**执行

```
<template>
  <div>{{ count }}</div>
</template>

<script>
export default {
  setup() {
    const count = ref(0)

    watchEffect(() => {
      console.log(count.value)
    })

    return {
      count
    }
  }
}
</script>
```

- `count` 会在初始运行时同步打印出来
- 更改 `count` 时，将在组件**更新前**执行副作用



如果需要在组件更新(例如：当与[模板引用](https://v3.cn.vuejs.org/guide/composition-api-template-refs.html#侦听模板引用)一起)**后**重新运行侦听器副作用，我们可以传递带有 `flush` 选项的附加 `options` 对象 (默认为 `'pre'`)：

```js
// 在组件更新后触发，这样你就可以访问更新的 DOM。
// 注意：这也将推迟副作用的初始运行，直到组件的首次渲染完成。
watchEffect(
  () => {
    /* ... */
  },
  {
    flush: 'post'
  }
)
```

`flush` 选项还接受 `sync`，这将强制效果始终同步触发。然而，这是低效的，应该很少需要



## Effect 作用域 API

高阶的 API，主要服务于库作者。

| API             | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| effectScope     | 创建 effect 作用域对象，以捕获在其内部创建的响应式 effect (例如计算属性或侦听器)，使得这些 effect 可以一起被处理 |
| getCurrentScope | 如果有，则返回当前活跃的 effect 作用域                       |
| onScopeDispose  | 在当前活跃的 effect 作用域上注册一个处理回调                 |

