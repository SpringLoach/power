## 整理位置

- vue2-coderwhy
- 原目录下的webpack、实例
- 待整理

- https://blog.csdn.net/weixin_46862327/article/details/125364534 √



## 准备环境

### 准备初始文件环境

```elm
- webpack-demo
  + public
    - index.html
  + src
    - banner.js
    - index.js
    - tabs.js
```



<span style="backGround: #efe0b9">public/index.html</span>

```html
<body>
  <div>轮播图</div>
  <div>tabs标签页</div>
</body>

<script src="../src/index.js"></script>
```

<span style="backGround: #efe0b9">src/banner.js</span>

```javascript
console.log('实现轮播图的业务逻辑')
```

<span style="backGround: #efe0b9">src/tabs.js</span>

```javascript
console.log('实现tabs标签页的逻辑')
```

<span style="backGround: #efe0b9">src/index.js</span>

```javascript
import './banner.js'
import './tabs.js'
```

此时用 Live Server 启动 index.html 会报错，因为直接使用了 import；

使用 webpack 可以解决这个问题，它内置了对 CommonJS 模块化的处理。



### webpack的使用

```elm
# 初始化包环境
yarn init -y

# 安装依赖包
yarn add webpack webpack-cli -D
```

安装脚本

<span style="backGround: #efe0b9">package.json</span>

```json
"scripts": {
	"build": "webpack"
}
```

进行打包

```elm
yarn build
```

结果：生成默认dist目录和打包后默认main.js文件,默认会打包src下的index.js



## webpack的配置

> 目录/webpack.config.js

### 入口和出口

> 告诉webpack从哪开始打包, 打包后的文件生成在哪个位置。

| 属性        | 默认值         | 版本     |
| ----------- | -------------- | -------- |
| entry       | ./src/index.js | webpack4 |
| output.path | ./dist/main.js | webpack4 |



#### demo

```javascript
const path = require("path")

module.exports = {
  entry: "./src/main.js", // 入口
  output: { 
    path: path.join(__dirname, "dist"), // 出口路径
    filename: "bundle.js", // 出口文件名
    clean: true // 每次打包前，删除原打包内容
  }
}
```

| 键             | 说明                             |
| -------------- | -------------------------------- |
| entry          | 需要打包的源文件                 |
| output.path    | 打包后的位置（绝对路径）         |
| filename       | 打包后的文件名                   |
| require        | 导出                             |
| path.resolve() | 拼接路径                         |
| __dirname      | 当前文件所在路径，注意是双下划线 |

**修改文件名**

```elm
- src
  - index.js ==> main.js
```

**重新打包后的结果**

```elm
- dist2
  + bundle.js
```



#### 配置出口文件名

```javascript
const path = require("path")

module.exports = {
  entry: "./src/main.js", // 入口
  output: { 
    path: path.join(__dirname, "dist"), // 出口路径
    filename: "js/[name].[hash:8].js",  // 出口文件名
    // filename: "js/[name].[hash:8].[ext]"
  }
}
```

:octopus: 这里测试，如果使用 [ext] ，将会被当做字符串视作为文件名的一部分，不太理解；

:flipper: 这里相当于在打包目录下创建一个 js 文件夹，用于存放打包后的文件。

| 配置     | 说明            |
| -------- | --------------- |
| [name]   | 原文件名字      |
| [hash:8] | 生成 8 位哈希值 |
| [ext]    | 原文件拓展名    |
| []       | 代表变量        |



### 打包流程图

![image-20230302220743798](.\img\打包流程图.png)



### mode模式

```javascript
module.exports = {
  mode: 'production',  // // 设置 process.env.NODE_ENV 的值
}
```

| 模式值      | 翻译     | 说明                 |
| ----------- | -------- | -------------------- |
| development | 开发阶段 | 简易打包，打包速度快 |
| production  | 发布阶段 | 打包精细，打包速度慢 |

production 会对源码做一些丑化和优化；

development 会把 webpack 的 devtool 设置为 evel。



### 自动生成html-插件

1. 下载插件

   ```elm
   yarn add html-webpack-plugin  -D
   ```

2. webpack.config.js

   ```javascript
   // 引入自动生成 html 的插件
   const HtmlWebpackPlugin = require('html-webpack-plugin')
   
   module.exports = {
       // ...省略其他代码
       plugins: [
           new HtmlWebpackPlugin()
       ]
   }
   ```

3. 打包并观察

   ```less
   - dist
     + index.html # 自动引入bundle.js
     + bundle.js
   ```

4. 自定义打包的html模版，和输出文件名字

   ```javascript
   plugins: [
     new HtmlWebpackPlugin({
       template: './public/index.html',
       filename: 'index.html'
     })
   ]
   ```

   

### 启动本地服务器

修改代码需要打包才能看到最新效果，但打包的过程很耗时；

可以开起一个开发服务器, 在电脑内存中打包, 缓存一些已经打包过的内容, 只重新打包修改的文件, 最终运行加载在内存中给浏览器使用；

启动本地服务, 可实时更新修改的代码, 打包**变化代码**到内存中, 然后直接提供端口和网页访问。



#### 基本使用

1. 下载包

   ```elm
   yarn add webpack-dev-server -D
   ```

2. 配置自定义命令

   <span style="backGround: #efe0b9">package.json</span>

   ```json
   scripts: {
   	// ...
   	"serve": "webpack serve"
   }
   ```

3. 启动webpack开发服务器

   ```elm
   yarn serve
   ```

   

#### 配置方式一

<span style="backGround: #efe0b9">package.json</span>

```json
"scripts": {
  // ...
  "serve": "webpack serve --port 8083 --open"
},
```

#### 配置方式二

<span style="backGround: #efe0b9">webpack.config.js</span>

```javascript
module.exports = {
    // ...其他配置
    devServer: {
      port: 3000, // 本地服务器占用的端口号
      open: true  // 服务器启动完成自动打开到浏览器
    }
}
```



### 处理css文件-加载器

**测试**

<span style="backGround: #efe0b9">src/style/index.css</span>

```apl
.banner {
  width: 100px;
  height: 100px;
  background-color: hotpink;
}
```

<span style="backGround: #efe0b9">main.js</span>

```javascript
// 添加
import './style/index.css'
```

:octopus: webpack 默认只能处理js类型文件，所以此时直接运行项目会报错。



**支持配置**

1. 安装依赖

   ```elm
   yarn add style-loader css-loader -D
   ```

2. webpack.config.js

   ```javascript
   module.exports = {
       // ...其他代码
       module: { 
           rules: [ // loader的规则
             {
               test: /\.css$/, // 匹配所有的css文件
               // use数组里从右向左运行
               // 先用 css-loader 让webpack能够识别 css 文件的内容并打包
               // 再用 style-loader 将样式, 把css插入到dom中
               use: [ "style-loader", "css-loader"]
             }
           ]
       }
   }
   ```

   

### 处理less文件-加载器

**测试**

<span style="backGround: #efe0b9">src/style/index.less</span>

```apl
body {
  .tabs {
    width: 400px;
    height: 40px;
    background-color: pink;
  }
}
```

<span style="backGround: #efe0b9">main.js</span>

```javascript
// 添加
import './style/index.less'
```

:octopus: webpack 默认只能处理js类型文件，所以此时直接运行项目会报错。



**支持配置**

1. 安装依赖

   ```elm
   yarn add less less-loader -D
   ```

2. webpack.config.js

   ```javascript
   module.exports = {
       // ...其他代码
       module: { 
           rules: [
             {
               // 使用less-loader, 让webpack处理less文件
               // 并能够将less转译成css代码
               test: /\.less$/,
               use: ["style-loader", "css-loader", 'less-loader']
             }
           ]
       }
   }
   ```

   



### 处理图片-加载器

**测试**

1. 定义盒子结构

   ```html
   <div class="box"></div>
   <div class="box2"></div>
   ```

2. 通过样式设置背景图

   ```css
   .box {
     width: 100px;
     height: 100px;
     background-image: url(../assets/logo_small.png);
   }
   
   .box2 {
     width: 100px;
     height: 100px;
     background-image: url(../assets/1.gif);
   }
   ```

3. 打包

   会在打包目录下生成对应的一样数量的图片，且页面正常展示



**配置**

webpack5

```javascript
module.exports = {
    // ...其他代码
    module: { 
        rules: [
          {
            test: /\.(png|jpg|gif|jpeg)$/i,
            type: 'asset'
          }
        ]
    }
}
```

打包后发现图片被转化为了 base64 在js文件中出现，包总体积略增大；推测是体积小的图才转:question:

:whale: 博客也有 [webpack4](https://blog.csdn.net/m0_66492535/article/details/127529556) 的配置。



#### 处理策略

- 以8kb进行区分，小于8kb图片转成 base64 字符串

  - 好处是可以减少浏览器的请求次数，直接从js中读取
  - 缺点是如果图片太大，再转`base64`就会让图片的体积增大 30% 左右

  

### 处理字体文件-加载器

**测试**

1. 准备并引入字体文件

   <span style="backGround: #efe0b9">main.js</span>

   ```javascript
   // 引入字体图标文件
   import '../assets/fonts/iconfont.css'
   ```

2. 使用字体图标样式

   <span style="backGround: #efe0b9">public/index.html</span>

   ```html
   <i class="iconfont icon-weixin"></i>
   ```

   

**配置**

webpack5

```javascript
module.exports = {
    // ...其他代码
    module: { 
        rules: [
          {
            // webpack5默认内部不认识这些文件, 所以当做静态资源直接输出即可
            test: /\.(eot|svg|ttf|woff|woff2)$/,
            type: 'asset/resource',
            generator: {
              filename: 'font-[name].[hash:6][ext]'
            }
          }
        ]
    }
}
```

按照上面的测试，这里配置与否没有影响文件数量和包体积大小

据说可配置可不配置，有什么区别吗:question:

:whale: 博客也有 [webpack4](https://blog.csdn.net/m0_66492535/article/details/127529556) 的配置。



### 处理ES6-加载器

**测试**

<span style="backGround: #efe0b9">main.js</span>

```javascript
// 添加
class App {
  static a = 123
}
console.log(App.a)
```

:whale: <span style="color: #ff0000">不是所有的浏览器都支持ES6</span>，使用 Chrome 测试支持很多新语法，但无法保证全部都支持。



**说明**

> babel-loader 可以让 webpack 对高版本js语法做降级处理后打包。

| 依赖              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| @babel/core       | babel的核心库，所有的核心Api都在这个库里，这些Api供babel-loader调用 |
| @babel/preset-env | 一个预设的插件集合，包含了一组相关的插件，Bable中是通过各种插件来指导如何进行代码转换。该插件包含所有es6转化为es5的翻译规则 |



**配置**

1. 安装包

   ```elm
   yarn add -D babel-loader @babel/core @babel/preset-env
   ```

2. 配置规则

   ```javascript
   module: {
     rules: [
       {
           test: /\.js$/,
           exclude: /(node_modules)/,
           use: {
               loader: 'babel-loader',
               options: {
                   presets: ['@babel/preset-env'] 
               }
           }
       }
     ]
   }
   ```

   

### 配置拓展名

> 配置后，导入对应类型文件时，可以省略后缀。

```javascript
module.exports = {
  // 其他配置
  resolve: {
    extensions: [".js", ".css", ".vue"],
  },
};
```



### 配置别名

**配置写法一**

```javascript
const path = require("path");
const resolve = (dir) => path.resolve(__dirname, dir);

module.exports = {
  // 其它配置
  resolve: {
    alias: {
      "@": resolve("src"),
      style: resolve("src/style"),
    },
  },
};
```

:octopus: 注意不要在配置中使用多个 resolve 属性，会报一些找不到头绪的error。

**配置写法二**

```javascript
const path = require("path");

module.exports = {
  // 其它配置
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "src"),
      style: "@/style",
    },
  },
};
```

**使用示例**

```javascript
import "@/style/index";
import "style/index.less";
```





### 配置版权信息-插件

```javascript
const webpack = require('webpack')

module.exports = {
    ...
    plugins: [
        new webpack.BannerPlugin('最终版权归大自然所有')
    ]
}
```



### 压缩代码-插件

```elm
npm install uglifyjs-webpack-plugin -S -D
```

<span style="backGround: #efe0b9">webpack.config.js</span>

```javascript
const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin')

plugins: [
    new UglifyjsWebpackPlugin()
]
```

:star2: 将删除所有的注释，与【配置版权信息的插件】冲突。

:question: webpack5 以上内置，应该只能应用于 webpack4 以下的版本，否则存在依赖版本问题。



### 配置文件的分离-工具(待)

- 项目文件
  - build
    - base.config.js
    - prod.config.js
    - dev.config.js

| 文件           | 包含配置 |
| -------------- | -------- |
| base.config.js | 公共     |
| prod.config.js | 生产     |
| dev.config.js  | 开发     |

实际使用时，将 `base.config.js` 的配置添加到生产/开发的配置中。

1. 安装

```elm
npm install webpack-merge@4.1.5 --save-dev
```

1. 合成配置（以生产为例）

- 在生产文件中导入 `webpack-merge` 和 `base.config` 文件
- 使用 `webpackMerge()` 方法合并 `base.config` 文件与生产配置 `module.exports`

```react
const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin')
const webpackMerge = require('webpack-merge')
const baseConfig = require('./base.config')

module.exports = webpackMerge(baseConfig ,{
    plugins: [
      new UglifyjsWebpackPlugin()
  ]
})
```

1. 指定配置文件

```react
/* package.json 的脚本中 */
"build": "webpack --config ./build/prod.config.js"
"dev": "webpack-dev-server --open --config ./build/dev.config.js"
```



### 启动项目时的提示-插件

```elm
npm install friendly-errors-webpack-plugin -D -S
```



```javascript
const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin');

module.exports = {
  ...
  plugins: [
    new FriendlyErrorsPlugin({
      // 成功提示
      compilationSuccessInfo: {
        messages: [
          `Your application is running here: http://localhost:8088`,
        ],
      },
      onErrors: undefined,
    }),
  ]
}
```



### 筛选日志输出-配置

```javascript
module.exports = {
    // ...其他配置
    stats: 'errors-only' // 只在发生错误时输出到控制台
}
```

:ghost: 在启动项目时可以过滤掉分析信息，开发出错时的信息也更简洁。



### 编译报错页面提醒-配置

```javascript
module.exports = {
    // ...其他配置
    devServer: {
      port: 3000, // 本地服务器占用的端口号
      // 当出现编译错误或警告时，在浏览器中显示全屏覆盖
      client: {
        overlay: {
          errors: true,
          warnings: false, // 警告时不进行全屏覆盖
        },
      },
    }
}
```







