## 存储引擎

### MySQL体系结构

![image-20230127105856907](.\img\mysql体系结构)



- 连接层
最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。
- 服务层
第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。
- 引擎层
存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。
- 存储层
主要是将数据存储在文件系统之上，并完成与存储引擎的交互。



### 简介

<span style="color: #a50">存储引擎</span>就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的而不是基于库的，所以存储引擎也可被称为<span style="color: #a50">表类型</span>。

```sql
# 查询建表语句（可以看到使用的存储引擎）
show create table demo;

# 查看当前数据库支持的存储引擎
show engines;
```

**解读**

```sql
CREATE TABLE `demo` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `name` varchar(30) NOT NULL COMMENT '姓名',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='示例表'
```

| 字段            | 说明                         |
| --------------- | ---------------------------- |
| ENGINE          | 使用的存储引擎（默认InnoDB） |
| AUTO_INCREMENT  | 自增的，插入的下一条数据的值 |
| DEFAULT CHARSET | 字符集                       |
| CHARSET         | 排序方式                     |
| COMMENT         | 注释信息                     |

**例子**

```sql
# 创建表 demo，并指定存储引擎为MyISAM
create table demo(
    id int,
    name varchar(10)
) engine = MyISAM;
```



### InnoDB

> InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，作为默认存储引擎。

**特点**

- DML操作遵循ACID模型，支持<span style="color: #ff0000">事务点</span>；
- <span style="color: #ff0000">行级锁</span>，提高并发访问性能；
- 支持<span style="color: #ff0000">外键</span> FOREIGN KEY 约束，保证数据的完整性和正确性。

**文件**

innoDB引擎的每张表会对应一个名为 <span style="backGround: #efe0b9">xxx.ibd</span> 的表空间文件，存储该表的表结构（frm、sdi）、数据和索引。

**逻辑存储结构**

![image-20230127130240119](.\img\逻辑存储结构)



### MyISAM

> MyISAM 是 MySQL 早期的默认存储引擎。

**特点**

- 不支持事务，不支持外键
- 支持表锁，不支持行锁
- 访问速度快

**文件**

- <span style="backGround: #efe0b9">xxx.sdi</span> 存储表结构信息
- <span style="backGround: #efe0b9">xxx.MYD</span> 存储数据
- <span style="backGround: #efe0b9">xxx.MYI</span> 存储索引



### Memory

> Memory 引擎的表数据是存储在内存中的，受到硬件问题、断电问题影响，只能作为临时表或缓存使用。

**特点**

- 内存存放
- hash索引（默认）

**文件**

- <span style="backGround: #efe0b9">xxx.sdi</span> 存储表结构信息

![image-20230127130810139](.\img\MyISAM和Memory)



### 选择使用

- <span style="color: #ff0000">InnoDB</span>：支持事务和外键，适合对事务完整性和并发有较高要求，包含很多更新删除操作的情景；
- MyISAM：适合的场景，以读取和插入为主，较少更新和删除，对事务完整性和并发有要求不高；
- MEMORY：通常用于临时表和缓存，对表大小有限制，无法保障数据的安全性。

:whale: 由于存在 mongodb 和 redis 的关系，后两种可以被替代而不使用。



## 索引

### 概述

索引是帮助 MySQL 高效<span style="color: #ff0000">获取</span>数据的（有序的）<span style="color: #ff0000">数据结构</span>。

**演示**

![image-20230127141441370](.\img\索引演示)

:flipper: 上述二叉树索引结构只是一个示意图，并非真实的索引结构。

**优缺点**

| 优势                                          | 劣势                         |
| --------------------------------------------- | ---------------------------- |
| 提高数据检索的效率，降低数据库的IO成本        | 索引列需要占用空间           |
| 通过索引列对数据排序，降低排序成本和CPU的消耗 | 查找效率提高，增删改效率降低 |



### 索引结构

#### 介绍

| 索引结构                                        | 描述                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| <span style="color: #ff0000">B+tree 索引</span> | 最常见的索引类型，大部分引擎都支持                           |
| Hash 索引                                       | 底层数据结构由哈希表实现，只有精确匹配索引列的查询生效，不支持范围查询 |
| R-tree（空间索引）                              | 是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型   |
| Full-text（全文索引）                           | 是一种通过建立倒排索引，快速匹配文档的方式                   |

**支持情况**

| 索引                  | InnoDB          | MyISAM | Memory |
| --------------------- | --------------- | ------ | ------ |
| B+tree 索引           | √               | √      | √      |
| Hash 索引             | /               | /      | √      |
| R-tree（空间索引）    | /               | √      | /      |
| Full-text（全文索引） | 5.6版本之后支持 | √      | /      |



#### B-tree

二叉树

![image-20230127150619795](.\img\二叉树)

多路平衡查找树

![image-20230127150814768](.\img\多路平衡查找树)

:whale: 具体动态变化过程可参考[网站](https://www.cs.usfca.edu/~galles/visualization/BTree.html)



#### B+tree

**普通B+tree**

![image-20230127151532609](.\img\B+tree)

相对于B-tree

- 索引的数据都会在叶子节点出现（且数据保存在叶子节点）
- 叶子节点形成一个单向链表

**MySQL中的B+tree**

![image-20230127151748535](.\img\(MySQL)B+tree)



#### Hash

![image-20230127152418753](.\img\hash)

**特点**

- 只能用于对等比较（=、 in），不支持范围查询（between、<、>）；
- 无法利用索引完成排序操作
- 查询效率高，通常只需要一次检索即可，效率通常高于 B+tree 索引

**存储引擎支持**

在MysQL中，支持hash索引的是Memory引擎，而innoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。



### 分类

| 分类     | 含义                                         | 特点                     | 关键字   |
| -------- | -------------------------------------------- | ------------------------ | -------- |
| 主键索引 | 针对表中主键创建的索引                       | 默认自动创建，只能有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复             | 可以有多个               | UNIQUE   |
| 常规索引 | 快速定位特定数据                             | 可以有多个               |          |
| 全文索引 | 查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | FULLTEXT |

在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：

| 分类     | 含义                                                       | 特点             |
| -------- | ---------------------------------------------------------- | ---------------- |
| 聚集索引 | 将数据存储与索引放在一起，索引结构的叶子节点保存了行数据   | 必须有且只有一个 |
| 二级索引 | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个     |

聚集索引选取规则：

- 如果存在主键，主键索引就是聚集索引；
- 如果不存在主键，将使用第一个唯一索引作为聚集索引；
- 如果表没有主键，或没有合适的唯一索引，那InnoDB会自动生成一个rowid作为隐藏的聚集索引。

![image-20230127160518305](.\img\索引分类)

执行某些SQL查询时，会先根据二级索引查询，再进行聚集索引查询。

![image-20230127160624142](.\img\回表查询)



### 操作

**语法**

```sql
# 创建索引
create [unique|fulltext] index index_name on table_name (index_col_name, ...);

# 查看索引
show index from table_name;

# 删除索引
drop index index_name on table_name;
```

**例子**

```sql
# name字段可能会重复，为其创建索引（常规索引）
create index idx_user_name on tb_user(name);

# phone字段为非空且唯一的，为其创建唯一索引
create unique index idx_user_phone on tb_user(phone);

# 为profession、age、status创建联合索引
create index idx_user_pro_age_sta on tb_user(profession, age, status);

# 为email建立合适的索引来提升查询效率
create index idx_user_email on tb_user(email);
```



### 性能分析

#### 查看执行频率

```sql
# 查看服务器状态信息
show [session|global] status;

# 查看当前数据库的增删查改访问频次
show global status like 'Com_______';
# Com_delete 删
# Com_insert 增
# Com_select 查
# Com_update 改
```



#### 慢查询日志

慢查询日志记录了所以执行时间超过设定时间(默认10s)的所有SQL语句的日志；



```sql
# 查询慢查询日志是否开启
show variables like 'slow_query_log';
```

针对Linux的开启方式：

MySQL的慢查询日志默认没有开启，需要在 <span style="backGround: #efe0b9">mysql配置文件/etc/my.cnf</span> 中配置如下

```sql
# 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2s
long_query_time=2
```

配置完毕后，重启MySQL以进行测试，慢日志文件位置 <span style="backGround: #efe0b9">/var/lib/mysql/localhost-slow.log</span>



#### profiles

**查看开启情况**

```sql
# 查看当前数据库是否支持profile操作
select @@have_profiling;

# 查看是否开启profile
select @@profiling;

# 开启profile
set @@profiling = 1;
```

**查看执行情况**

```sql
# 查看所有SQL的耗时基本情况(含query_id)
show profiles;

# 查看指定query_id的SQL语句各阶段耗时
show profile for query query_id;

# 查看指定query_id的SQL语句CPU使用情况
show profile cpu for query query_id;
```



#### explain

可以通过 explain 或者 desc 命令获取 MySQL 执行 SELECT 语句的信息，包含连接方式和顺序等。

**语法**

```sql
# 直接在查询语句钱加关键字 explain / desc
explain select 字段列表 from 表名 where 条件;
```

**字段含义**

| 字段         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| ID           | 查询的序列号，表示执行select/操作表的顺序（id值越大越先执行；id相同，执行顺序从上到下） |
| select_type  | 表示SELECT的类型                                             |
| type         | 连接类型，性能由好到差为 NULL、system、const（主键/唯一索引）、eq_ref、ref、range、index、all |
| possible_key | 显示可能应用在这张表上的索引，一个或多个                     |
| key          | 实际使用的索引，如果为null，表示没有使用索引                 |
| key_len      | 表示索引中使用的字节数，为索引字段最大可能长度（越短越好）   |
| rows         | 估计值，认为要执行查询的行数                                 |
| filered      | 表示返回结果的行数占需读行数的百分比（越大越好）             |

| select_type值 | 含义                              |
| ------------- | --------------------------------- |
| simple        | 简单表，即不使用表连接或子查询    |
| primary       | 主查询，即外层的查询              |
| union         | union中的第二个或者后面的查询语句 |
| subquery      | select/where之后包含了子查询      |



### 使用规则

#### 校验索引效率

**例子**

```sql
## 假设demo表有100万条数据

# 在未建立索引之前，执行SQL
select* from demo where id = 43421343;         # 耗时0.01s
select * from demo where name = 'smallvsbig';  # 耗时21s

# 建立索引后，查看耗时
create index idx_demo_name on demo(name);
select * from demo where name = 'smallvsbig';  # 耗时0.01s
```



#### 最左前缀法则

这个规则适用于联合索引。

- 索引的最左列（第一项）必须存在，否则不会使用该联合索引；
- 如果跳过了索引的某一列，该索引后面的（索引项）部分将失效；
- 这与SQL中的条件字段摆放顺序无关。

```sql
# 为profession、age、status创建联合索引
create index idx_user_pro_age_sta on tb_user(profession, age, status);

# 使用了联合索引
explain select * from tb_user where age = 2 and status = '0' and profession = 'a';
explain select * from tb_user where profession = 'a' and age = 2;
explain select * from tb_user where profession = 'a';
# 没使用联合索引
explain select * from tb_user where age = 2 and status = '0';
```

**范围查询**

联合索引中，出现范围查询（>/<）时，范围查询右侧的列索引失效

```sql
# 位于age右侧的索引status失效
explain select * from tb_user where profession = 'a' and age > 2 and status = '0';
# 位于age右侧的索引status生效，即使用>=可以避免失效
explain select * from tb_user where profession = 'a' and age >= 2 and status = '0';
```



#### 索引失效情况

##### 索引列运算

在索引列上进行运算操作

```sql
select * from tb_user where substring(phone, 10, 2) = '15';
```



##### 字符串不使用引号

字符串类型字段使用时，不加引号；

联合索引的非最左侧列没有使用相应字符串类型时，其及右侧索引失效

```sql
select * from tb_user where profession = '软件工程' and status = 0;
select * from tb_user where phone = 17799990015;
```



##### 模糊查询

如果仅仅是尾部模糊匹配，索引不会失效；但若头部模糊匹配，索引失效。

```sql
# 会失效
select * from tb_user where profession like '软件%';
# 不会失效
select * from tb_user where profession like '%工程';
```



##### or连接的条件

or 需要两边字段都满足存在索引的条件，才能使用索引；任一方无均不会使用索引

```sql
# 不会走索引，因为age无关联的索引
select * from tb_user where id = 10 or age = 23;
# 会走主键索引和联合索引
select * from tb_user where phone = '177999900017' or id = 10;
```



##### 数据分布影响

如果 MySQL 评估使用索引比全表更慢，则不使用索引

```sql
# 大部分数据比17799990005大，走全表扫描
select * from tb_user where phone >= '17799990005';
# 小部分数据比17799990015大，走索引
select * from tb_user where phone >= '17799990015';
```



#### SQL提示

一个字段可以关联到多个索引上，届时使用查询 MySQL 将自动选择其认为的最优索引，可以控制该行为。

```sql
# 建议使用某个索引，MySQL不一定采用
select * from tb_user use index(idx_name) where profession = '软件工程';
# 排除某个索引
select * from tb_user ignore index(idx_name) where profession = '软件工程';
# 强制使用某个索引
select * from tb_user force index(idx_name) where profession = '软件工程';
```

:hammer_and_wrench: 其中的 idx_name 需替换为索引的实际名称。



#### 覆盖索引

使用的索引中已经包含了需要返回的所有字段信息，就称为覆盖索引。

这样可以避免使用回表查询从而提高性能；

由于二级索引的叶子节点中已经存在 id，所以获取 id 信息也不需要回表查询；

减少使用 `select *` 也是为了减少回表查询。



**例子**

表demo有四个字段(id, username, password, status)，由于数据量大，需要优化下面的SQL：

```sql
select id, username, password from tb_user where username = 'itcast';
```

做法：使用字段 username 和 password 建立联合索引。



#### 前缀索引

对于较大的字符串和长文本，直接建立索引会占据大量的磁盘IO，且影响查询效率；此时可以截取字符串的部分前缀，建立索引，这样能节约索引空间，从而提高索引效率。

**语法**

```sql
create index idx_name on table_name(column(n));
```

**前缀长度选择**

可以根据不重复的索引值和数据表的记录总数的比值作为依据选择，最好的值为1。



**例子**

```sql
# 查看截取五位前缀时的数值反映
select count(distinct substring(email, 1, 5))/count(*) from tb_user;

# 建立前缀索引
create index idx_email_5 on tb_user(email(5));
```



**前缀索引查询流程**

```sql
select * from tb_user where email = 'asdsa@qq.com'
```

先截取前五个字符 `asdsa` 的部分，在前缀二级索引中匹配，然后根据id进行回表查询，再比较对于记录的 email 字段是否与目标字段一致。



#### 单列&联合索引

在业务场景中，如果存在多个查询条件，考虑针对查询字段建立索引时，建议使用联合索引（单列索引会触发回表查询）。

```sql
# 即使有phone、name的单列索引，也只会使用某个索引，然后回表查询
select id, phone, name from tb_user where phone = '123213' and name = 'abc';

# 创建phone&name多列索引
create unique index idx_user_phone_name on tb_user(phone, name);

# 多条件联合查询时，MySQL也可能会去选择使用单列索引，从而还是发生回表查询
select id, phone, name from tb_user where phone = '123213' and name = 'abc';
# 可以通过SQL提示改变选取的索引
select id, phone, name from tb_user use index(idx_user_phone_name) where phone = '123213' and name = 'abc';
```



#### 设计原则

1. 针对于数据量较大（百万级别），且<span style="color: #ff0000">查询</span>比较频繁的表建立索引。
2. 针对于常作为查询条件（where)、排序（order by)、分组(group by)操作的字段建立索引。
3. 尽量选择<span style="color: #ff0000">区分度高</span>的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，<span style="color: #ff0000">会影响增删改的效率</span>。
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。



## SQL优化

### 插入数据

对于需要插入大量数据（500~1000）的场景，一条条插入的效率是不高的。

```sql
insert into tb_test values(1, 'tom');
insert into tb_test values(1, 'cat');
insert into tb_test values(1, 'jerry');
......
```

  

#### 批量插入

在 500~1000 条记录时，可以选择批量插入；更多条时，拆为多条批量插入。

```sql
insert into tb_test values(1,'Tom'),(2, 'Cat'), (3, 'Jerry');
```

#### 手动提交事务

```sql
start transaction;
insert into tb_test values(1,'Tom'),(2, 'Cat'), (3, 'Jerry');
insert into tb_test values(4,'Tom'),(5, 'Cat'), (6, 'Jerry');
insert into tb_test values(7,'Tom'),(8, 'Cat'), (9, 'Jerry');
commit;
```

#### 主键顺序插入

```less
主键乱序插入：8 1 9 21 88 2 4 15 89 5 7 3
主键顺序插入：1 2 3 4 5 7 8 9 15 21 88 89
```

#### 大批量插入数据

数据量达到百万级别时，通过 MySQL 数据库提供的 load 指令效率更高

![image-20230129223115918](.\img\大批量插入数据)

```sql
# 客户端连接服务端时，加上参数 --local-infile
mysql --local-infile -u root -p
# 查看本地加载文件导入数据的开关
select @@local_infile;
# 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;
# 执行load指令将准备好的数据，加载到表结构中
load data local infile '/root/sql1.log' into table `tb_user` fields terminated by ',' lines terminated by '\n';
```



### 主键优化

在InnoDB存储引擎中，表数据都是<span style="color: #ff0000">根据主键顺序</span>组织存放的，这种存储方式的表称为索引组织表。

#### 主键设计原则

- 满足业务需求的情况下，尽量<span style="color: #ff0000">降低主键的长度</span>（二级索引会记录主键）；
- 插入数据时，尽量选择<span style="color: #ff0000">顺序插入</span>，选择使用 AUTO_INCREMENT 自增主键；
- 尽量不要使用 UUID 做主键或者是其它自然主键，如身份证号；
- 业务操作时，避免对主键的修改。



### order-by优化

- 根据排序字段建立合适的索引，多字段排序时，也遵循<span style="color: #ff0000">最左前缀法则</span>；
- 尽量使用覆盖索引；
- 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）；
- 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size。

| Extra结果           | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| Using filesort      | 通过表的索引/全表扫描，读取满足条件的数据行，在排序缓冲区sort buffer排序 |
| Using filesort      | 所有不是通过索引直接返回排序结果的排序。                     |
| Using index         | 通过有序索引顺序扫描直接返回有序数据。不需要额外排序，<span style="color: #ff0000">操作效率高</span> |
| Backward index scan | 表示反向扫描                                                 |
| Using temporary     | 使用临时表                                                   |

**例子**

```sql
# 创建索引
create index idx_user_age_phone_aa on tb_user(age, phone);

# 创建索引后，根据age进行升序排序——Using index
explain select id, age, phone from tb_user order by age;

# 创建索引后，根据phone进行升序排序——Using filesort
explain select id, age, phone from tb_user order by age;

# 创建索引后，根据age，phone进行升序排序——Using index;Backward index scan
explain select id, age, phone from tb_user order by age, phone;

# 创建索引后，根据age，phone进行降序排序——Using index
explain select id, age, phone from tb_user order by age desc, phone desc;
```

```sql
# 根据age，phone排序，一个升序，一个降序——Using filesort
explain select id, age, phone from tb_user order by age asc, phone desc;
# 创建索引
create index idx_user_age_phone_ad on tb_user(age asc, phone desc);
# 根据age，phone排序，一个升序，一个降序——Using index
explain select id, age, phone from tb_user order by age asc, phone desc;
```

:whale: 创建索引时，如果没有指定字段的排序方式，默认按照升序。



### group-by优化

**例子**

```sql
# 执行分组操作，根据profession字段分组——Using temporary
explain select profession, count(*) from tb_user group by profession;

# 创建索引
create index idx_user_pro_age_sta on tb_user(profession, age, status);

# 执行分组操作，根据age字段分组——Using index;Using temporary
explain select profession, count(*) from tb_user group by age;

# 执行分组操作，根据profession字段分组——Using index
explain select profession, count(*) from tb_user group by profession;

# 执行分组操作，根据profession字段分组——Using index
explain select profession, count(*) from tb_user group by profession, age;

# 执行分组操作，profession条件后根据age字段分组——Using index
explain select profession, count(*) from tb_user where profession = '软件工程' group by age;
```





