## 项目框架搭建

**初始化包管理**

```elm
npm init -y
```

**基于Koa开发**

```elm
npm install koa
```

```elm
npm install nodemon -D
```

**配置快捷键**

<span style="backGround: #efe0b9">package.json</span>

```json
"scripts": {
  "start": "nodemon ./src/main.js"
}
```

<span style="backGround: #efe0b9">目录结构</span>

```elm
- src
  + app    		// 全局相关
  + controller  // 控制器
  + router      // 路由
  + service     // 数据库
  + utils       // 工具
  + main.js     // 入口
```

<span style="backGround: #efe0b9">main.js</span>

```javascript
const Koa = require('koa');

const app = new Koa();

app.listen(8000, () => {
  console.log(`服务器启动成功~`);
});
```



### 将配置信息写入环境变量

```elm
- 项目
  + src
    - app
      + config.js
      + index.js
    - main.js
  + .env
```

**将配置信息抽离**

<span style="backGround: #efe0b9">src\app\index.js</span>

```javascript
const Koa = require('koa');

const app = new Koa();

module.exports = app;
```

**编写环境变量文件**

<span style="backGround: #efe0b9">.env</span>

```elm
APP_PORT=8000
```

:turtle: 需要将该文件添加到 `.gitignore` 中，每个设备的配置应该是不同的，且保密的。

**配置环境变量**

```elm
npm install dotenv
```

:turtle: 借助该库可以将 `.env` 中的配置添加到环境变量中

<span style="backGround: #efe0b9">src\app\config.js</span>

```javascript
const dotenv = require('dotenv');

dotenv.config();

module.exports = {
  APP_PORT
} = process.env;
```

**重构入口文件**

<span style="backGround: #efe0b9">main.js</span>

```javascript
const app = require('./app');
const config = require('./app/config');

app.listen(config.APP_PORT, () => {
  console.log(`服务器在${config.APP_PORT}端口启动成功~`);
});
```



### 配置路由-组织架构

```elm
npm install koa-router
```

#### 添加路由（预封装）

<span style="backGround: #efe0b9">src\app\index.js</span>

> 实际开发中，要将下面的逻辑进行抽离。

```javascript
const Koa = require('koa');

const Router = require('koa-router');

const app = new Koa();

// 创建路由实例，添加处理
const userRouter = new Router({prefix: '/users'});

userRouter.post('/', (ctx, next) => {
  ctx.body = "创建用户成功"；
})

// 注册路由
app.use(userRouter.routes());
 // 对不支持的方法提醒
app.use(userRouter.allowedMethods());

module.exports = app;
```

#### 封装架构

```elm
- 项目
  + src
    - app
      + index.js
    - controller            // 实现处理逻辑
      + user.controller.js
    - router                // 抽离出对路由的配置
      + user.router.js      // 具体业务层（只负责注册接口，不实现处理逻辑）
    - service               // 补充处理逻辑（补充实现查询数据的部分）
      +user.service.js
```

#### 注册接口

<span style="backGround: #efe0b9">src\router\user.router.js</span>

>  只负责注册接口，不实现处理逻辑

```javascript
const Router = require('koa-router');
const {
  create
} = require('../controller/user.controller');

const userRouter = new Router({prefix: '/users'});

userRouter.post('/', create);

module.exports = userRouter;
```

#### 实现处理逻辑

<span style="backGround: #efe0b9">src\controller\user.controller.js</span>

>  实现处理逻辑，但不会去实现查询数据的部分

```javascript
const service = require('../service/user.service');

class UserController {
  async create(ctx, next) {
    // 获取用户请求传递的参数
    const user = ctx.request.body;
  
    // 查询数据
    const result = await service.create(user);
  
    // 返回数据
    ctx.body = result;
  }
}

module.exports = new UserController();
```

#### 实现查询逻辑

<span style="backGround: #efe0b9">src\service\user.service.js</span>

> 实现查询数据的部分

```javascript
class UserService {
  async create(user) {
    console.log("将user存储到数据库中", user);
    // 将user存储到数据库中
    return "创建用户成功";
  }
}

module.exports = new UserService();
```

#### 添加解析JSON

<span style="backGround: #efe0b9">src\app\index.js</span>

```elm
npm install koa-bodyparser
```

```javascript
const Koa = require('koa');
const bodyParser = require('koa-bodyparser');
const userRouter = require('../router/user.router');

const app = new Koa();

app.useRoutes = useRoutes;

app.use(bodyParser()); // 添加，用于解析JSON
app.use(userRouter.routes());
app.use(userRouter.allowedMethods());

module.exports = app;
```

:ghost: `bodyParser()` 需要在注册路由前调用，才能保证生效。



## 用户表

#### **创建用户表**

```sql
CREATE TABLE `user` (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(30) NOT NULL UNIQUE,
  password VARCHAR(50) NOT NULL,
  createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```



#### 连接数据库

```sql
npm install mysql2 
```

```elm
- src
  + app
    - databse.js // 数据库连接相关
```

**添加数据库登录信息到环境变量**

<span style="backGround: #efe0b9">.env</span>

```elm
APP_PORT=8000

MYSQL_HOST=localhost
MYSQL_PORT=3306
MYSQL_DATABASE=xxx
MYSQL_USER=root
MYSQL_PASSWORD=xxx
```

<span style="backGround: #efe0b9">src\app\config.js</span>

```javascript
const dotenv = require('dotenv');

dotenv.config();

module.exports = {
  APP_PORT,
  MYSQL_HOST,
  MYSQL_PORT,
  MYSQL_DATABASE,
  MYSQL_USER,
  MYSQL_PASSWORD,
} = process.env;
```

<span style="backGround: #efe0b9">src\app\database.js</span>

```javascript
const mysql = require('mysql2');

const config = require('./config');

const connections = mysql.createPool({
  host: config.MYSQL_HOST,
  port: config.MYSQL_PORT,
  database: config.MYSQL_DATABASE,
  user: config.MYSQL_USER,
  password: config.MYSQL_PASSWORD
});

connections.getConnection((err, conn) => {
  conn.connect((err) => {
    if (err) {
      console.log("连接失败:", err);
    } else {
      console.log("数据库连接成功~");
    }
  })
});

module.exports = connections.promise(); // 直接导出它的期约形式，供其它地方使用
```

**添加到入口以实现加载**

<span style="backGround: #efe0b9">main.js</span>

```javascript
require('./app/database');
```



#### 实现添加账号记录

<span style="backGround: #efe0b9">src\service\user.service.js</span>

```javascript
const connection = require('../app/database'); // 导入的是期约形式

class UserService {
  // 创建账号，插入到数据库
  async create(user) {
    const { name, password } = user;
    const statement = `INSERT INTO user (name, password) VALUES (?, ?);`;
    const result = await connection.execute(statement, [name, password]);

    return result;
  }
}

module.exports = new UserService();
```



### 非空校验

```elm
- src
  + app
    - error-handle.js // 错误事件处理
    - index.js        // 配置服务器实例
  + constants
    - error-types.js  // 错误常量
  + middleware		  // 实现中间件逻辑
    - user.middleware.js
```

#### 添加校验中间件

<span style="backGround: #efe0b9">src\router\user.router.js</span>

```javascript
const Router = require('koa-router');
const {
  create
} = require('../controller/user.controller');
const {
  verifyUser
} = require('../middleware/user.middleware');

const userRouter = new Router({prefix: '/users'});

userRouter.post('/', verifyUser, create); // 添加一个校验中间件

module.exports = userRouter;
```

:point_down: 校验中间件的逻辑在其它地方实现。

<span style="backGround: #efe0b9">src\middleware\user.middleware.js</span>

```javascript
const errorTypes = require('../constants/error-types');

const verifyUser = async (ctx, next) => {
  // 1.获取用户名和密码
  const { name, password } = ctx.request.body;

  // 2.判断用户名或者密码不能空
  if (!name || !password) {
    const error = new Error(errorTypes.NAME_OR_PASSWORD_IS_REQUIRED);
    return ctx.app.emit('error', error, ctx); // 触发事件（错误事件）
  }

  // 3.判断这次注册的用户名是没有被注册过

  await next(); // 不执行这一步的话，就不会执行下一个中间件
}

module.exports = {
  verifyUser
}
```

:point_down: 将错误类型定义为常量，并保存在其它文件。

#### 保存错误常量

<span style="backGround: #efe0b9">src\constants\error-types.js</span>

```javascript
const NAME_OR_PASSWORD_IS_REQUIRED = 'name_or_password_is_required';

module.exports = {
  NAME_OR_PASSWORD_IS_REQUIRED
}
```

#### 注册错误事件

<span style="backGround: #efe0b9">src\app\index.js</span>

```javascript
const Koa = require('koa');
const bodyParser = require('koa-bodyparser');
const errorHandler = require('./error-handle'); // 添加
const useRoutes = require('../router');

const app = new Koa();

app.useRoutes = useRoutes;

app.use(bodyParser());
app.useRoutes();
app.on('error', errorHandler); // 添加

module.exports = app;
```

#### 处理错误事件

<span style="backGround: #efe0b9">src\app\error-handle.js</span>

```javascript
const errorTypes = require('../constants/error-types');

const errorHandler = (error, ctx) => {
  let status, message;

  switch (error.message) {
    case errorTypes.NAME_OR_PASSWORD_IS_REQUIRED:
      status = 400; // Bad Request
      message = "用户名或者密码不能为空~";
      break;
    default:
      status = 404;
      message = "NOT FOUND";
  }

  ctx.status = status;
  ctx.body = message;
}

module.exports = errorHandler;
```



### 账号重复校验

> 相关逻辑可以在校验中间件中补充。

#### 实现账号校验逻辑

<span style="backGround: #efe0b9">src\service\user.service.js</span>

```javascript
const connection = require('../app/database');

class UserService {
  // 插入记录
  async create(user) {
    const { name, password } = user;
    const statement = `INSERT INTO user (name, password) VALUES (?, ?);`;
    const result = await connection.execute(statement, [name, password]);

    return result[0];
  }

  // 查询记录-防重（添加）
  async getUserByName(name) {
    const statement = `SELECT * FROM user WHERE name = ?;`;
    const result = await connection.execute(statement, [name]);

    return result[0];
  }
}

module.exports = new UserService();
```



#### 添加账号检验逻辑

<span style="backGround: #efe0b9">src\middleware\user.middleware.js</span>

```javascript
const errorTypes = require('../constants/error-types');
const service = require('../service/user.service');

const verifyUser = async (ctx, next) => {
  // 1.获取用户名和密码
  const { name, password } = ctx.request.body;

  // 2.判断用户名或者密码不能空
  if (!name || !password) {
    const error = new Error(errorTypes.NAME_OR_PASSWORD_IS_REQUIRED);
    return ctx.app.emit('error', error, ctx);
  }

  // 3.判断这次注册的用户名是没有被注册过（添加）
  const result = await service.getUserByName(name);
  if (result.length) {
    const error = new Error(errorTypes.USER_ALREADY_EXISTS);
    return ctx.app.emit('error', error, ctx);
  }

  await next(); // 调用才会执行下一个中间件
}

module.exports = {
  verifyUser
}
```



#### 补充错误处理

<span style="backGround: #efe0b9">src\constants\error-types.js</span>

```javascript
const NAME_OR_PASSWORD_IS_REQUIRED = 'name_or_password_is_required';
const USER_ALREADY_EXISTS = 'user_already_exists';

module.exports = {
  NAME_OR_PASSWORD_IS_REQUIRED,
  USER_ALREADY_EXISTS
}
```

<span style="backGround: #efe0b9">src\app\error-handle.js</span>

```javascript
const errorTypes = require('../constants/error-types');

const errorHandler = (error, ctx) => {
  let status, message;

  switch (error.message) {
    case errorTypes.NAME_OR_PASSWORD_IS_REQUIRED:
      status = 400; // Bad Request
      message = "用户名或者密码不能为空~";
      break;
    case errorTypes.USER_ALREADY_EXISTS:
      status = 409; // conflict
      message = "用户名已经存在~";
      break;
    default:
      status = 404;
      message = "NOT FOUND";
  }

  ctx.status = status;
  ctx.body = message;
}

module.exports = errorHandler;
```



### 入库前加密

```elm
- src
  + utils
    - password-handle.js // 加密方法
```

#### 注册加密

可以在校验中间件后，额外添加一个处理密码的中间件。

```javascript
const Router = require('koa-router');
const {
  create
} = require('../controller/user.controller');
const {
  verifyUser,
  handlePassword
} = require('../middleware/user.middleware');

const userRouter = new Router({prefix: '/users'});

userRouter.post('/', verifyUser, handlePassword, create); // 修改

module.exports = userRouter;
```



#### 实现加密中间件

<span style="backGround: #efe0b9">src\middleware\user.middleware.js</span>

```javascript
const errorTypes = require('../constants/error-types');
const service = require('../service/user.service');
const md5password = require('../utils/password-handle');

const verifyUser = async (ctx, next) => {
  // ...
}

// 加密中间件
const handlePassword = async (ctx, next) => {
  const { password } = ctx.request.body;
  ctx.request.body.password = md5password(password)

  await next();
}

module.exports = {
  verifyUser,
  handlePassword
}
```



#### 实现加密方法

<span style="backGround: #efe0b9">src\utils\password-handle.js</span>

```javascript
const crypto = require('crypto');

const md5password = (password) => {
  const md5 = crypto.createHash('md5'); // 选择加密方式
  const result = md5.update(password).digest('hex');
  return result;
}

module.exports = md5password;
```

:turtle: `digest()` 用于取出加密结果，默认是 Buffer 形式，设置为 `hex` 即为十六进制。



### 实现登录结构

> 先实现大体的架构，没有校验等环节。

#### 注册接口

<span style="backGround: #efe0b9">src\router\auth.router.js</span>

```javascript
const Router = require('koa-router');

const authRouter = new Router();

const {
  login
} = require('../controller/auth.controller');

authRouter.post('/login', login);

module.exports = authRouter;
```

#### 实现处理逻辑

<span style="backGround: #efe0b9">src\controller\auth.controller.js</span>

```javascript
class AuthController {
  async login(ctx, next) {
    const { name } = ctx.request.body;
    ctx.body = `登录成功，欢迎${name}回来~`
}

module.exports = new AuthController();
```

#### 添加注册的接口

<span style="backGround: #efe0b9">src\app\index.js</span>

```javascript
const Koa = require('koa');
const bodyParser = require('koa-bodyparser');

const userRouter = require('../router/user.router');
const authRouter = require('../router/auth.router');
const errorHandler = require('./error-handle'); 

const app = new Koa();

app.useRoutes = useRoutes;

app.use(bodyParser());
app.use(userRouter.routes());
app.use(userRouter.allowedMethods());
app.use(authRouter.routes());
app.use(authRouter.allowedMethods());

app.on('error', errorHandler);

module.exports = app;
```





### 登录校验

#### 添加校验中间件

<span style="backGround: #efe0b9">src\router\auth.router.js</span>

```javascript
const Router = require('koa-router');

const authRouter = new Router();

const {
  login
} = require('../controller/auth.controller');
const {
  verifyLogin
} = require('../middleware/auth.middleware');

authRouter.post('/login', verifyLogin, login); // 添加验证登录中间件

module.exports = authRouter;
```

#### 实现校验逻辑

<span style="backGround: #efe0b9">src\middleware\auth.middleware.js</span>

```javascript
const errorTypes = require('../constants/error-types');
const userService = require('../service/user.service');
const md5password = require('../utils/password-handle');

const verifyLogin = async (ctx, next) => {
  // 1.获取用户名和密码
  const { name, password } = ctx.request.body;

  // 2.判断用户名和密码是否为空
  if (!name || !password) {
    const error = new Error(errorTypes.NAME_OR_PASSWORD_IS_REQUIRED);
    return ctx.app.emit('error', error, ctx);
  }

  // 3.判断用户是否存在的
  const result = await userService.getUserByName(name);
  const user = result[0]; // 取出查询结果的第一个
  if (!user) {
    const error = new Error(errorTypes.USER_DOES_NOT_EXISTS);
    return ctx.app.emit('error', error, ctx);
  }

  // 4.判断密码加密后是否和数据库中的密码一致
  if (md5password(password) !== user.password) {
    const error = new Error(errorTypes.PASSWORD_IS_INCORRENT);
    return ctx.app.emit('error', error, ctx);
  }

  ctx.user = user;
  await next();
}

module.exports = {
  verifyLogin
}
```



#### 处理错误事件

<span style="backGround: #efe0b9">src\constants\error-types.js</span>

```javascript
const NAME_OR_PASSWORD_IS_REQUIRED = 'name_or_password_is_required';
const USER_ALREADY_EXISTS = 'user_already_exists';
const USER_DOES_NOT_EXISTS = 'user_does_not_exists';
const PASSWORD_IS_INCORRENT = 'password_is_incorrent';

module.exports = {
  NAME_OR_PASSWORD_IS_REQUIRED,
  USER_ALREADY_EXISTS,
  USER_DOES_NOT_EXISTS,
  PASSWORD_IS_INCORRENT
}
```

<span style="backGround: #efe0b9">src\app\error-handle.js</span>

```javascript
const errorTypes = require('../constants/error-types');

const errorHandler = (error, ctx) => {
  let status, message;

  switch (error.message) {
    case errorTypes.NAME_OR_PASSWORD_IS_REQUIRED:
      status = 400; // Bad Request
      message = "用户名或者密码不能为空~";
      break;
    case errorTypes.USER_ALREADY_EXISTS:
      status = 409; // conflict
      message = "用户名已经存在~";
      break;
    case errorTypes.USER_DOES_NOT_EXISTS:
      status = 400; // 参数错误
      message = "用户名不存在~";
      break;
    case errorTypes.PASSWORD_IS_INCORRENT:
      status = 400; // 参数错误
      message = "密码是错误的~";
      break;
    default:
      status = 404;
      message = "NOT FOUND";
  }

  ctx.status = status;
  ctx.body = message;
}

module.exports = errorHandler;
```



### 抽离路由注册入口

```elm
- src
  + router
    - auto.router.js
    - user.router.js
    - index.js       // 入口文件
```

<span style="backGround: #efe0b9">src\router\index.js</span>

```javascript
const fs = require('fs');

const useRoutes = function() {
  fs.readdirSync(__dirname).forEach(file => {
    if (file === 'index.js') return;
    const router = require(`./${file}`);
    this.use(router.routes()); // 注册到服务器实例
    this.use(router.allowedMethods()); // 恰当不支持方法
  })
}

module.exports = useRoutes;
```

:turtle: 文件夹下除了入口文件，剩余的导出一个路由实例。

<span style="backGround: #efe0b9">src\app\index.js</span>

```javascript
const Koa = require('koa');
const bodyParser = require('koa-bodyparser');
const errorHandler = require('./error-handle');
const useRoutes = require('../router');

const app = new Koa();

app.useRoutes = useRoutes;

app.use(bodyParser());
app.useRoutes();
app.on('error', errorHandler);

module.exports = app;
```

:turtle: 对象调用时，方法中的 `this` 指向该对象。



### 发布登录凭证

> 在登录成功后，给用户返回 token 相关的信息。

```elm
- src
  + app
    - keys // 保存公钥和密钥
      + private.key
      + public.key
    - config.js // 全局配置
```

#### 将钥匙添加到配置

<span style="backGround: #efe0b9">src\app\config.js</span>

```javascript
const dotenv = require('dotenv');
const fs = require('fs');
const path = require('path');

dotenv.config();

const PRIVATE_KEY = fs.readFileSync(path.resolve(__dirname, './keys/private.key'));
const PUBLIC_KEY = fs.readFileSync(path.resolve(__dirname, './keys/public.key'));

module.exports = {
  APP_HOST,
  APP_PORT,
  MYSQL_HOST,
  MYSQL_PORT,
  MYSQL_DATABASE,
  MYSQL_USER,
  MYSQL_PASSWORD,
} = process.env;

module.exports.PRIVATE_KEY = PRIVATE_KEY;
module.exports.PUBLIC_KEY = PUBLIC_KEY;
```

<span style="backGround: #efe0b9">src\middleware\auth.middleware.js</span>

```javascript
const verifyLogin = async (ctx, next) => {
  // 1.获取用户名和密码
  // 2.判断用户名和密码是否为空
  // 3.判断用户是否存在的
  // 获取到user
  // 4.判断密码是否和数据库中的密码是一致(加密)

  ctx.user = user; // 添加
  await next();
}


module.exports = {
  verifyLogin
}
```

:point_down: 可以将已经获取到的信息添加到 `ctx` 中，传递给下一个中间件使用。



#### 实现发布

```elm
npm install jsonwebtoken
```

<span style="backGround: #efe0b9">src\controller\auth.controller.js</span>

```javascript
const jwt = require('jsonwebtoken');
const { PRIVATE_KEY } = require('../app/config');

class AuthController {
  async login(ctx, next) {
    const { id, name } = ctx.user; // 从上一个中间件传递过来
    const token = jwt.sign({ id, name }, PRIVATE_KEY, {
      expiresIn: 60 * 60 * 24,
      algorithm: 'RS256'
    });

    ctx.body = { id, name, token }
  }

  async success(ctx, next) {
    ctx.body = "授权成功~";
  }
}

module.exports = new AuthController();
```







