## 根路径下使用不同路由&子路由

> 利用兄弟路由，实现相同根路径的前提下，使用完全不同的（顶层）组件。

路由 | 说明
:- | :- 
目标路由 | 放置好了页面顶部、子路由区域（router-view）、页面底部
目标的子路由 | 将被渲染到子路由区域
目标的兄弟路由 | 将**替代**目标路由所对应的组件

> 栗子中的 `view/job/home.vue` 即为目标路由。


```javascript
const routes = [{
  path: '/job',
  name: 'job',
  component: () => import('../view/job/home'),
  children: [
    {
      path: '/',
      redirect: '/job/home',
    },{
      path: '/job/home',
      component: () => import('../view/job/main/main'),
    },{
      path: '/job/personal',
      component: () => import('../view/job/personal/personal'),
    }
  ]
  // 不在其 children 下，不会以内嵌组件形式存在
  },{
    path: '/job/login',
    name: 'jobLogin',
    component: () => import('../view/login.vue'),
  },{
    path: '/job/register',
    name: 'register',
    component: () => import('../view/register.vue'),
}];
```



## 路由导航守卫—控制跳转

```javascript
router.beforeEach((to, from, next) => {
	if(to.path=="/"){
		setPageTitle(to);
		return next("/job");
	}
	
	let entrance = app.getUrlRootName(to.path);
	if(entrance=="demo"){
		alert(to.path);
		setPageTitle(to);
		return next();
	}
	
	/****************未登录不拦截的处理****************/
	for (var i = 0; i < allowUnLoginPaths.length; i++) {
		if (to.path === allowUnLoginPaths[i]) {
			console.log("【路由导航守卫】对页面【" + allowUnLoginPaths[i] + "】不拦截");
			setPageTitle(to);
			return next();
		}
	}

	/****************判断是否登录校验****************/
	/* --------------------------------先不拦截---------------------------- */
	// if (!whetherLand) {
	// 	console.error("【路由导航守卫】拦截页面【" + to.path + "】,理由:未登录");
	// 	setPageTitle(to);
	// 	return next(loginPath);
	// }
	
	// /****************判断入口与登录信息是否一致****************/
	// let state = app.getState();
	// let allowEntrance = roleHelper.ROLE_CONFIG.allowEntrance(state,entrance);
	// if(!allowEntrance){
	// 	console.error("【路由导航守卫】拦截页面【" + to.path + "】,理由:角色与入口不匹配");
	// 	alert('当前登录用户与角色入口不匹配');
	// 	setPageTitle(to);
	// 	//return next(loginPath);
	// 	return;
	// }
	
	setPageTitle(to);
	next();
});
```

### 设置不同路由下的标题

> 可以在路由跳转，即 `next()` 前调用该方法。
>
> `baseConfig.js` 中将拥有特殊含义的名称保存为了常量。

`router/index.js`

```javascript
function setPageTitle(to){
    let pageTitle = to.meta.title;
    if(!pageTitle) {
        return
    } else {
        document.title = baseConfig.basicTitle + "-" + pageTitle
    }
}  
```

### 获取根路径

```javascript
// 子路径 '/demo' 会转化得到 ['', 'demo']
function getUrlRootName(path){
	let paths = path.split("/")[1]; 
	return paths;
};
```



## params VS query 

### params

跳转方式 | 代码
:-: | :-
① | this.$router.push('/demo/' + 123) 
② | this.$router.push({ name: 'Demo',  params: {id: 123} }) 
③| this.$router.push({ path: '/demo',  params: {id: 123} }) 

#### 对name的需求

跳转方式 | 需求 
:-: | :-
① | 不需要，有也不影响 
② | 必须要有 
③| 有无均不影响的错误方案 

#### 路径A

```javascript
const routes = [
  {
    path: '/demo/:id',
    name: 'Demo',
    component: Demo
  }
]
```

跳转方式 | 跳转后路径 | 正常页面 | $route.params
:-: | :- | :-: | :-:
① | `http://localhost:8080/demo/123` | √ |{id: 123}
② | `http://localhost:8080/demo/123` | √ |{id: 123}
③| `http://localhost:8080/demo` | × |/

#### 路径B

```javascript
const routes = [
  {
    path: '/demo',
    name: 'Demo',
    component: Demo
  }
]
```

跳转方式 | 跳转后路径 | 正常页面 | $route.params
:-: | :- | :-: | :-:
① | `http://localhost:8080/demo/123` | × |/
② | `http://localhost:8080/demo` | √ |{id: 123}
③| `http://localhost:8080/demo` | √ |{}

### query

跳转方式 | 代码
:-: | :-
① | this.$router.push('/demo?id=123') 
② | this.$router.push({ name: 'Demo',  query: {id: 123} }) 
③| this.$router.push({ path: '/demo',  query: {id: 123} }) 

#### 对name的需求

跳转方式 | 需求 
:-: | :-
① | 不需要，有也不影响 
② | 必须要有 
③| 不需要，有也不影响 

#### 路径A

```javascript
const routes = [
  {
    path: '/demo',
    name: 'Demo',
    component: Demo
  }
]
```

跳转方式 | 跳转后路径 | 正常页面 | $route.query 
:-: | :- | :-: | :-:
① | `http://localhost:8080/demo?id=123` | √ |{id: 123}
② | `http://localhost:8080/demo?id=123` | √ |{id: 123}
③| `http://localhost:8080/demo?id=123` | √ |{id: 123}



### 携带参数跳转页面

> 不需要更改路由（即额外添加动态参数）。

`栗子`

```javascript
toInformationDetail(id){
	this.$router.push({
		path:'/job/information',
		query:{
			id:id
		}
	});
},
```

`information.vue`

```javascript
created() {
	let id = this.$route.query.id;
	// 请求到数据后, 保存到本地
	this.loadDetail(id);
}
```

#### 

## 根据查询参数加载数据

`最佳实际`

> 通过设置 `immediate` 属性，可以立即触发回调，即从其它页面跳转过来时也能触发。
>
> **但是，在刷新当前页面时，不会触发回调？需测试**

```javascript
methods: {
  initPage() {
    /* 在这里根据路由改变实例数据 */ 
    /* 在这里请求页面需要的数据 */ 
  }
},
watch: {
  '$route.query': {
    handler: 'initPage',
    immediate: true
  }
}
```

`替代方案`

```javascript
/* 当前页面路由（查询参数）改变时触发 */
watch: {
  '$route': 'fetchData'
},
methods: {
  fetchData() {
    this.title = this.$route.query.id;
  },
  clickBtn() {
    let x = Math.random();
    this.$router.push({name: 'Demo',  query: {id: x}});
  }
},
created() {
  /* 其他页面跳转过来或刷新当前页面触发 */
  this.fetchData();
}
```



## 在新窗口打开路由页面

> 在新页面一样可以获取查询参数。

 ```javascript
// 点击具体的某个岗位
handleJobClick(id) {
  let routeData = this.$router.resolve({
    path: '/job/job-detail',
    query: {
      id,
    }
  });
  window.open(routeData.href, '_blank');
},
 ```

window.open

| 参数 | 说明                               |
| :--: | :--------------------------------- |
|  ①   | 在窗口中要显示网页的网址或路径     |
|  ②   | **窗口名称**，某些名称具有特殊意义 |
|  ③   | 新窗口的配置，如宽高、有无菜单     |

| 窗口名称  | 说明                               |
| :-------: | :--------------------------------- |
| ' _blank' | 在新窗口显示目标网页               |
|  '_self'  | 在当前窗口显示目标网页             |
|  '_top'   | 框架网页中在上部窗口中显示目标网页 |

